---
title: "modeling stroop effects (RTs) with RSA coding schemes"
author: "michael freund"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 3
---

## about

```{r setup, include = FALSE}

library(mikeutils)
library(magrittr)
library(here)
library(knitr)
library(dplyr)
library(data.table)
library(ggplot2)
library(grid)
library(gridExtra)
library(colorspace)
library(viridis)
library(nlme)
library(caret)
library(gtools)
library(vegan)

source(here("code", "strings.R"))

theme_set(theme_bw(base_size = 12))

## read data

blups <- read.csv(here("out", "behav", "stroop_blups_rt_group201902.csv"), stringsAsFactors = FALSE)
blups.validation <- read.csv(
  here("out", "behav", "stroop_blups_rt_group201902_validation.csv"), stringsAsFactors = FALSE
  )
stats.subjs.tdic <- fread(
  here("out", "rsa", "stats", paste0("subjs_pro_bias_acc-only_masks_pearson_residual_glm-tdic.csv"))
)

## subset and bind

stats.subjs.tdic.validation <- stats.subjs.tdic[is.analysis.group == FALSE, ]  ## EXCLUDE HELD OUT SUBJECTS!
stats.subjs.tdic.validation <- stats.subjs.tdic.validation[y == "rank" & param %in% c("target", "distractor", "incongruency"), ]
stats.subjs.tdic.validation <- stats.subjs.tdic.validation[, c("coef", "y", "model") := NULL]  ## remove useless cols
stats.subjs.tdic.validation <- full_join(blups.validation, stats.subjs.tdic.validation, by = "subj")

## format cols

stats.subjs.tdic.validation <- cbind(
  stats.subjs.tdic.validation,
  reshape2::colsplit(stats.subjs.tdic.validation$roi, "_", c("roi.set", "superparcel"))
)
stats.subjs.tdic.validation$superparcel[stats.subjs.tdic.validation$superparcel == ""] <- "vwfa"

stats.subjs.tdic <- stats.subjs.tdic[is.analysis.group == TRUE, ]  ## EXCLUDE HELD OUT SUBJECTS!
stats.subjs.tdic <- stats.subjs.tdic[y == "rank" & param %in% c("target", "distractor", "incongruency"), ]
stats.subjs.tdic <- stats.subjs.tdic[, c("coef", "y", "model") := NULL]  ## remove useless cols

stats.subjs.tdic <- full_join(blups, stats.subjs.tdic, by = "subj")

## format cols

stats.subjs.tdic <- cbind(
  stats.subjs.tdic,
  reshape2::colsplit(stats.subjs.tdic$roi, "_", c("roi.set", "superparcel"))
)
stats.subjs.tdic$superparcel[stats.subjs.tdic$superparcel == ""] <- "vwfa"

## functions

split.str.item <- function(col.j, prefix = "") {
  ## takes a single "item" vector, e.g. "blueBLUE", and decomposes
  ## it into color ("blue") word ("BLUE"), congruency ("C"), and label 
  ## ("C.BLUE", for plotting). 
  # prefix <- paste0(col.j, ".")
  col.j      <- as.character(col.j)
  color      <- gsub("[A-Z]", "", col.j)
  word       <- gsub("[a-z]", "", col.j)
  congruency <- ifelse(color == tolower(word), "C", "I")
  label      <- paste0(congruency, ".", word)
  cols       <- as.data.frame(cbind(color, word, congruency, label))
  colnames(cols) <- paste0(prefix, c("color", "word", "congruency", "label"))
  return(cols)
}

mds.to.df <- function(mat) {
  mat %>%
    as.data.frame %>%
    tibble::rownames_to_column("stim") %>%
    bind_cols(., split.str.item(.$stim))
}

plot.mds <- function(df) {
  df %>%
    ggplot(aes(MDS1, MDS2)) +
    geom_label(aes(label = word, color = color), fill = "grey60", fontface = "bold", label.size = 0) +
    scale_color_manual(values = setNames(bias.colors, bias.colors)) +
    theme(
      panel.background = element_blank(), 
      axis.text = element_blank(), 
      legend.position = "none", 
      axis.ticks = element_blank()
    )
}

## strings

colors.model <- c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")

```

The goal is to estimate which of a set of regressors best predicts individual differences in Stroop effect (RTs).
The regressors are fits from three RSA coding schemes: a _target_, _distractor_, and _incongruency_ model.
Each RSA coding scheme was obtained from evoked activity within a "super-parcel".
Thus, the initial set of regressors contains $N_{\text{superparcel}} * N_{\text{coding scheme}}$ regressors.

## feature selection

* compute bivariate correlations between each regressor and Stroop effect
  * use both spearman and pearson
  * check for multivariate outliers via stahel-donoho projection techique (from WRS2 package, code lifted from [here]( https://github.com/cran/WRS2/blob/master/R/outpro.R)
  * select regressors that have $R^2$ in top 20 within both pearson's and spearman's
    * <= 20 regressors will keep the model comparison procedure (below) tractable

```{r feature-selection, fig.width = 20, fig.height = 10, cache = TRUE}

## (1) bivariate correlations ----

d <- stats.subjs.tdic %>% filter(roi.set %in% c("anat") | superparcel %in% c("vwfa", "smmouth"))

d %<>%
  group_by(superparcel, param) %>%
  mutate(
    n = seq_len(n()),
    is.out.line = n %in% outpro(partr, stroop)$out.id,
    is.out.rank = n %in% outpro(rank(partr), rank(stroop))$out.id
  )

d.validation <- 
  stats.subjs.tdic.validation %>% 
  filter(roi.set %in% c("anat") | superparcel %in% c("vwfa", "smmouth")) %>%
  group_by(superparcel, param) %>%
  mutate(
    n = seq_len(n()),
    is.out.line = n %in% outpro(partr, stroop)$out.id,
    is.out.rank = n %in% outpro(rank(partr), rank(stroop))$out.id
  )


topcors <- d %>%
  group_by(superparcel, param) %>%
  summarize(
    r.line = cor(beta, stroop),
    r.rank = cor(beta, stroop, method = "spearman"),
    r2.line = r.line^2,
    r2.rank = r.rank^2,
    r.line.nout = sum(is.out.line),
    r.rank.nout = sum(is.out.rank)
  ) %>%
  ungroup %>%
  filter(rank(-r2.line) < 26 & rank(-r2.rank) < 26) %>%
  arrange(-r2.line) %>%
  mutate(id = interaction(superparcel, param))

kable(topcors, digits = 2)

## plot

d %<>% mutate(id = as.character(interaction(superparcel, param)))
d.validation %<>% mutate(id = as.character(interaction(superparcel, param)))
  # filter(id %in% topcors$id)

d %>%
  group_by(id) %>%
  mutate(
    beta.z = scale(beta),
    stroop.z = scale(stroop),
    r = cor(beta, stroop)
  ) %>%
  ggplot(aes(beta.z, stroop.z, fill = param)) +
  facet_grid(vars(param), vars(superparcel)) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  stat_boot_ci(n = 1E4, fill = "grey50", alpha = 0.5) +
  geom_point(shape = 21, color = "white", size = 2)

```

This narrows it down to a set of `r nrow(topcors)` regressors.

## model comparison

* multple regression via OLS
* all possible combinations of selected regressors (above) will be fit
* expected test error estimated via MSE from 10-fold cross-validation
* this procedure will be repeated 5 times and MSEs averaged across repetitions 
* two types of models will be noted:
  * __minimum MSE__: the model that yields minimum MSE
  * __optimal MSE__: the model(s) with fewest parameters that yield within 1 SE of __minimum MSE__ model

### code

```{r model-comparison, cache = TRUE}

## to wide

w <- d %>%
  ungroup %>%
  dplyr::select(subj, congr, stroop, beta, id) %>%
  tidyr::spread(id, beta)

w.validation <- d.validation %>%
  ungroup %>%
  dplyr::select(subj, congr, stroop, beta, id) %>%
  tidyr::spread(id, beta)

## build model combinations

varnames <- as.character(unique(d$id))
nvars <- length(varnames)
combs <- lapply(1:nvars, function(x) gtools::combinations(n = nvars, r = x))  ## row indicates columns of design matrix
nmods <- sum(sapply(combs, nrow))
mse <- vector("list", nmods)
X <- as.matrix(w[varnames])
strooprt <- w$stroop
mod <- mse
k <- 10

## build cross-validation folds

set.seed(0)
folds <- lapply(
  1:5, 
  function(.) createFolds(strooprt, k = k, list = TRUE, returnTrain = FALSE)
)
mse.rep.i <- matrix(NA, ncol = k, nrow = length(folds))  ## for storing MSEs hot off press

print(cbind(sapply(combs, nrow)))  ## number of models (inner loop) per combination (outer loop)

## estimate test error

starttime <- Sys.time()
a <- 1
for (comb.i in seq_along(combs)) {
  # comb.i = 1

  comb <- combs[[comb.i]]

  for (model.i in seq_len(nrow(comb))) {
    # model.i = 2

    ## build model

    regs.i <- comb[model.i, ]  ## indices for regressors
    Xi <- cbind(b0 = 1, X[, regs.i])
    colnames(Xi)[-1] <- varnames[regs.i]

    ## get response (folds)
    
    for (rep.i in seq_along(folds)) {
      # rep.i = 1
      
      unlist.me <- lapply(
        folds[[rep.i]],
        function(., x, y) {
          xtrn <- x[-., ]
          xtst <- x[., ]
          ytrn <- y[-.]
          ytst <- y[.]
          fit  <- .lm.fit(xtrn, ytrn)
          yhat <- xtst %*% fit$coefficients
  
          mean((ytst - yhat)^2)
  
        },
        x = Xi,
        y = strooprt
      )
      
      mse.rep.i[rep.i, ] <- unlist(unlist.me, use.names = FALSE)
      
    }
    
    # mse[[a]] <- colMeans(mse.rep.i)  ## average MSEs across repetitions
    mse[[a]] <- c(mse.rep.i)
    mod[[a]] <- varnames[regs.i]

    a <- a + 1

  }

  print(comb.i)

}
(endtime <- Sys.time() - starttime)

```

### results

#### minimum MSE model

```{r min-mse, fig.height = 10, fig.width = 10}

mse.bar <- vapply(mse, mean, numeric(1))  ## MSEs per model (averaged across folds)
m.best <- which.min(mse.bar)
se.best <- sd(mse[[m.best]]) / sqrt(length(mse[[m.best]]))  ## expected SE of test error for min mse model
nparams <- vapply(mod, length, numeric(1)) + 1  ## number of params of each model
mse[m.best] %>% unlist %>% mean / k  ## MSE per fold
mod[m.best]  ## winning model params

range(mse.bar)
# plot(nparams, mse.bar)

fit.best <- lm(scale(strooprt) ~ ., data = as.data.frame(scale(X[, mod[[m.best]]])))
summary(fit.best)
par(mfrow = c(2, 2))
plot(fit.best)

## TODO: make better plot!

```

#### optimum MSE model (using 1SE rule)

<!-- * question: __by averaging across repetitions, is the SE(test MSE) underestimated?__ -->

```{r optim-mse, fig.height = 10, fig.width = 10}

thresh <- mse.bar[m.best] + se.best
is.below <- mse.bar < thresh
is.parsim <- nparams <= min(nparams[is.below])
is.viable <- is.below & is.parsim

mod[is.viable]  ## least complex mods within 1SE(MSE) of best model
sapply(mse[is.viable], function(.) mean(unlist(.)) / k)  ## their MSEs

(mod.winning <- mod[is.viable][[which.min(mse.bar[is.viable])]])  ## of those, the model with lowest MSE

fit.optim <- lm(scale(strooprt) ~ ., data = as.data.frame(scale(X[, mod.winning])))
summary(fit.optim)
par(mfrow = c(2, 2))
plot(fit.optim)

```


```{r}


library(glmnet)
names(w)
m <- stats.subjs.tdic %>% 
  filter(roi.set %in% c("anat") | superparcel %in% c("vwfa", "smmouth")) %>%
  ungroup %>%
  mutate(id = paste0(superparcel, "_", param)) %>%
  select(subj, stroop, beta, id) %>%
  tidyr::pivot_wider(-subj, names_from = "id", values_from = "beta") %>%
  as.matrix

set.seed(0)
elnet05.cv <- cv.glmnet(m[, -grep("stroop", colnames(m))], m[, "stroop"])
elnet05 <- glmnet(m[, -grep("stroop", colnames(m))], m[, "stroop"], alpha = 1, lambda = elnet05.cv$lambda.min)
plot(elnet05.cv)
coef(elnet05)
plot(elnet05)


## validation set error ----

m.validation <- stats.subjs.tdic.validation %>% 
  filter(roi.set %in% c("anat") | superparcel %in% c("vwfa", "smmouth")) %>%
  ungroup %>%
  mutate(id = paste0(superparcel, "_", param)) %>%
  select(subj, stroop, beta, id) %>%
  tidyr::pivot_wider(-subj, names_from = "id", values_from = "beta") %>%
  as.matrix


setdiff(colnames(m.validation), colnames(m))
setdiff(colnames(m), colnames(m.validation))

yhat <- predict(elnet05.cv, s = "lambda.min" , newx = m.validation[, -grep("stroop", colnames(m))])
sqrt(mean((m.validation[, "stroop"] - yhat)^2))
cor(m.validation[, "stroop"], yhat)
plot(m.validation[, "stroop"], yhat)



## [1] 1.452
sqrt(mean((fires$lburned[inds.valid] - yhat.fires.valid)^2))
## [1] 1.34


# ----

library(selectiveInference)
all(svd(m[, -grep("stroop", colnames(m))])$d > 0)
path <- lar(m[, -grep("stroop", colnames(m))], m[, "stroop"])
pathinf <- larInf(path)
pathinf

w <- as.matrix(w[, -1])
path2 <- lar(w[, -grep("stroop", colnames(w))], w[, "stroop"])
pathinf2 <- larInf(path2)
pathinf2


colnames(m)[c(46, 7, 72, 51, 5) + 1]


## stability selection ----
install.packages("stabs")
library("stabs")
library("lars")
stab.lasso <- stabsel(
  x = m[, -grep("stroop", colnames(m))], y = m[, "stroop"], fitfun = glmnet.lasso, 
  cutoff = 0.6, PFER = 1
  )
stab.lasso
plot(stab.lasso)


```















```{r optim-mse_plot, fig.width = 15}

# d <- d %>%
#   select(subj, congr, incon, superparcel, param, beta) %>%
#   as.data.table %>%
#   melt(value.name = "rt", id.vars = c("subj", "superparcel", "param", "beta"), measure.vars = c("congr", "incon"))

w.scale <- data.frame(scale(w[mod.winning]))

w.resid <- data.frame(
  dlpfc_L.distractor  = lm(lppc_R.target ~ ., w.scale)$resid,
  lppc_R.target       = lm(lppc_R.target ~ ., w.scale)$resid,
  mfc_L.incongruency  = lm(mfc_L.incongruency ~ ., w.scale)$resid,
  vvis_L.incongruency = lm(vvis_L.incongruency ~ ., w.scale)$resid
)

partials <- cbind(blups, w.resid)

cor(partials$stroop, partials$mfc_L.incongruency)
cor(partials$stroop, partials$lppc_R.target)
cor(partials$stroop, partials$vvis_L.incongruency)

par(mfrow = c(1, 4))
plot(partials$mfc_L.incongruency, partials$stroop, pch = 16)
plot(partials$lppc_R.target, partials$stroop, pch = 16)
plot(partials$vvis_L.incongruency, partials$stroop, pch = 16)
plot(partials$dlpfc_L.distractor, partials$stroop, pch = 16)


d.long <- stats.subjs.tdic %>% 
  filter(
    roi.set == "anatfunc", superparcel %in% c("mfc_L", "dlpfc_L", "vvis_L", "lppc_R")
    )
nsim <- 1E4
d.long %<>%
  mutate(
    is.selected.param = ifelse(
      (superparcel == "dlpfc_L" & param == "distractor") |
        (superparcel %in% c("vvis_L", "mfc_L") & param == "incongruency") |
        (superparcel == "lppc_R" & param == "target"), 
      TRUE,
      FALSE
    ),
    note.incon = ifelse(superparcel == "dlpfc_L" & param == "distractor", "incongruency", ""),
    note.targt = ifelse(superparcel == "dlpfc_L" & param == "distractor", "target", ""),
    note.distr = ifelse(superparcel == "dlpfc_L" & param == "distractor", "distractor", "")
  )
note.incon <- data.frame(
  superparcel = "dlpfc_L",
  param = "distractor",
  lab = "conflict"
)
note.distr <- data.frame(
  superparcel = "dlpfc_L",
  param = "distractor",
  lab = "distractor"
)
note.targt <- data.frame(
  superparcel = "dlpfc_L",
  param = "distractor",
  lab = "target"
)

plot.range <- d.long %>% 
  filter(superparcel %in% c("dlpfc_L", "vvis_L", "mfc_L", "lppc_L")) %>%
  summarize(
    max.stroop = max(stroop),
    min.stroop = min(stroop),
    min.beta = min(beta),
    max.beta = max(beta)
  )

d.long %>%
  ggplot(
    aes(beta, stroop, fill = param, color = param)
    ) +
  stat_boot_ci(aes(alpha = ifelse(is.selected.param, 0.4, 0.15)), n = nsim, color = "transparent") +
  geom_smooth(
    data = d.long %>% filter(is.selected.param),
    aes(alpha = ifelse(is.selected.param, 0.5, 0.1)), 
    method = "lm", se = FALSE
    ) +
  scale_alpha_identity() +
  geom_point(data = d.long %>% filter(is.selected.param), shape = 21, color = "white", size = 2) +
  facet_grid(cols = vars(superparcel)) +
  scale_color_manual(values = c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")) +
  scale_fill_manual(values = c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")) +
  theme_minimal(base_size = 15) +
  theme(
    axis.ticks       = element_line(),
    axis.text        = element_text(size = rel(0.5), color = "grey30"),
    # axis.text.y      = element_text(color = "transparent"),
    axis.title       = element_text(color = "grey30", face = "bold.italic"),
    # axis.title.y     = element_text(color = "transparent"),
    panel.background = element_blank(),
    panel.grid       =  element_blank(),
    legend.position  = "none",
    legend.direction = "horizontal",
    legend.title     = element_blank(),
    legend.text      = element_text(color = "grey30"),
    axis.line        = element_blank(),
    strip.background = element_blank(),
    strip.text       = element_text(face = "bold.italic", size = rel(0.75)),
    title            = element_text(face = "bold")
  ) +
  scale_x_continuous(
    breaks = c(plot.range$min.beta, 0, plot.range$max.beta) %>% round(2)
  ) +
  scale_y_continuous(
    breaks = c(plot.range$min.stroop, plot.range$max.stroop) %>% round(2)
  ) +
  geom_segment(
    aes(y = plot.range$min.stroop, yend = plot.range$max.stroop, x = -Inf, xend = -Inf),
    color = "grey50", size = 0.25
    ) +
  geom_segment(
      aes(x = plot.range$min.beta, xend = plot.range$max.beta, y = -Inf, yend = -Inf),
      color = "grey50", size = 0.25
      ) +
  labs(x = "RSA model fit (beta)", y = "Stroop effect (RT)", title = "a") +
  geom_text(
    data = note.incon, aes(label = lab), color = colors.model["incongruency"], x = -Inf, y = 10, 
    fontface = "bold", vjust = 0, hjust = 0
    ) +
  geom_text(
    data = note.targt, aes(label = lab), color = colors.model["target"], x = -Inf, y = 20, 
    fontface = "bold", vjust = 0, hjust = 0
    ) +
  geom_text(
    data = note.distr, aes(label = lab), color = colors.model["distractor"], x = -Inf, y = 30, 
    fontface = "bold", vjust = 0, hjust = 0
    )



p.selected.model <- d.long %>%
  filter(is.selected.param) %>%
  ggplot(
    aes(beta, stroop, fill = param, color = param)
    ) +
  stat_boot_ci(alpha = 0.4, n = nsim, color = "transparent") +
  geom_smooth(
    alpha = 0.5,
    # data = d.long %>% filter(is.selected.param),
    # aes(alpha = ifelse(is.selected.param, 0.5, 0.1)), 
    method = "lm", se = FALSE
    ) +
  # scale_alpha_identity() +
  geom_point(data = d.long %>% filter(is.selected.param), shape = 21, color = "white", size = 2) +
  facet_grid(cols = vars(superparcel)) +
  scale_color_manual(values = c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")) +
  scale_fill_manual(values = c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")) +
  theme_minimal(base_size = 15) +
  theme(
    axis.ticks       = element_line(),
    axis.text        = element_text(size = rel(0.5), color = "grey30"),
    # axis.text.y      = element_text(color = "transparent"),
    axis.title       = element_text(color = "grey30", face = "bold.italic"),
    # axis.title.y     = element_text(color = "transparent"),
    panel.background = element_blank(),
    panel.grid       =  element_blank(),
    legend.position  = "none",
    legend.direction = "horizontal",
    legend.title     = element_blank(),
    legend.text      = element_text(color = "grey30"),
    axis.line        = element_blank(),
    strip.background = element_blank(),
    strip.text       = element_text(face = "bold.italic", size = rel(0.75)),
    title            = element_text(face = "bold")
  ) +
  scale_x_continuous(
    breaks = c(plot.range$min.beta, 0, plot.range$max.beta) %>% round(2)
  ) +
  scale_y_continuous(
    breaks = c(plot.range$min.stroop, plot.range$max.stroop) %>% round(2)
  ) +
  geom_segment(
    aes(y = plot.range$min.stroop, yend = plot.range$max.stroop, x = -Inf, xend = -Inf),
    color = "grey50", size = 0.25
    ) +
  geom_segment(
      aes(x = plot.range$min.beta, xend = plot.range$max.beta, y = -Inf, yend = -Inf),
      color = "grey50", size = 0.25
      ) +
  labs(x = "RSA model fit (beta)", y = "Stroop effect (RT)", title = "a") +
  geom_text(
    data = note.incon, aes(label = lab), color = colors.model["incongruency"], x = -Inf, y = 10, 
    fontface = "bold", vjust = 0, hjust = 0
    ) +
  geom_text(
    data = note.targt, aes(label = lab), color = colors.model["target"], x = -Inf, y = 20, 
    fontface = "bold", vjust = 0, hjust = 0
    ) +
  geom_text(
    data = note.distr, aes(label = lab), color = colors.model["distractor"], x = -Inf, y = 30, 
    fontface = "bold", vjust = 0, hjust = 0
    )

p.selected.model

ggsave(
  here("out", "figs", "ms_v1_2020-03", "indif_explor", "indif_explor.pdf"), 
  plot = p.selected.model,
  units = "cm",
  device = "pdf",
  height = 9,
  width = 9 * 3
)


p.additional <- d.long %>%
  filter(is.selected.param, roi %in% c("anatfunc_vvis_L", "anatfunc_dlpfc_L")) %>%
  ggplot(
    aes(beta, stroop, fill = param, color = param)
    ) +
  stat_boot_ci(alpha = 0.4, n = nsim, color = "transparent") +
  geom_smooth(
    alpha = 0.5,
    # data = d.long %>% filter(is.selected.param),
    # aes(alpha = ifelse(is.selected.param, 0.5, 0.1)), 
    method = "lm", se = FALSE
    ) +
  # scale_alpha_identity() +
  geom_point(data = d.long %>% filter(is.selected.param, roi %in% c("anatfunc_vvis_L", "anatfunc_dlpfc_L")), shape = 21, color = "white", size = 2) +
  facet_grid(cols = vars(superparcel)) +
  scale_color_manual(values = c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")) +
  scale_fill_manual(values = c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")) +
  theme_minimal(base_size = 15) +
  theme(
    axis.ticks       = element_line(),
    axis.text        = element_text(size = rel(0.5), color = "grey30"),
    # axis.text.y      = element_text(color = "transparent"),
    axis.title       = element_text(color = "grey30", face = "bold.italic"),
    # axis.title.y     = element_text(color = "transparent"),
    panel.background = element_blank(),
    panel.grid       =  element_blank(),
    legend.position  = "none",
    legend.direction = "horizontal",
    legend.title     = element_blank(),
    legend.text      = element_text(color = "grey30"),
    axis.line        = element_blank(),
    strip.background = element_blank(),
    strip.text       = element_text(face = "bold.italic", size = rel(0.75)),
    title            = element_text(face = "bold")
  ) +
  scale_x_continuous(
    breaks = c(plot.range$min.beta, 0, plot.range$max.beta) %>% round(2)
  ) +
  scale_y_continuous(
    breaks = c(plot.range$min.stroop, plot.range$max.stroop) %>% round(2)
  ) +
  geom_segment(
    aes(y = plot.range$min.stroop, yend = plot.range$max.stroop, x = -Inf, xend = -Inf),
    color = "grey50", size = 0.25
    ) +
  geom_segment(
      aes(x = plot.range$min.beta, xend = plot.range$max.beta, y = -Inf, yend = -Inf),
      color = "grey50", size = 0.25
      ) +
  labs(x = "RSA model fit (beta)", y = "Stroop effect (RT)") +
  geom_text(
    data = note.incon, aes(label = lab), color = colors.model["incongruency"], x = -Inf, y = 10, 
    fontface = "bold", vjust = 0, hjust = 0
    ) +
  geom_text(
    data = note.distr, aes(label = lab), color = colors.model["distractor"], x = -Inf, y = 30, 
    fontface = "bold", vjust = 0, hjust = 0
    )

ggsave(
  here("out", "figs", "ms_v1_2020-03", "indif_explor", "fig_indif_explor_additional.pdf"), 
  plot = p.additional,
  units = "cm",
  device = "pdf",
  height = 7,
  width = 8 * 2
)


```

## testing hypotheses in MLM

* tested via cross-level interaction between fit to coding scheme and trial type

```{r mlm, cache = TRUE}

## fit MLM

fit <- readRDS(here("out", "behav", "fit1-het-trim_group201902.RDS"))
behav <- fit$data
behav %<>% full_join(cbind(subj = w$subj, w.scale), by = "subj")

fit.win <- lme(
  scale(rt) ~ trial.type + lppc_R.target + mfc_L.incongruency + vvis_L.incongruency + dlpfc_L.distractor +
    trial.type:lppc_R.target +
    trial.type:mfc_L.incongruency +
    trial.type:vvis_L.incongruency +
    trial.type:dlpfc_L.distractor,
  random  = ~ trial.type | subj,
  data    = behav,
  weights = varIdent(form = ~ 1 | subj),
  control = lmeControl(maxIter = 1e5, msMaxIter = 1e5, niterEM = 1e5, msMaxEval = 1e5),
  method  = "REML"
)

summary(fit.win)
# intervals(fit.winning, which = "fixed")


## TODO: set up double dissociation
# fit.pfc <- lme(
#   scale(rt) ~ trial.type * scheme * region,
#   random  = ~ trial.type | subj,
#   data    = behav,
#   weights = varIdent(form = ~ 1 | subj),
#   control = lmeControl(maxIter = 1e5, msMaxIter = 1e5, niterEM = 1e5, msMaxEval = 1e5),
#   method  = "REML"
# )


# ## plot: MLM
# 
# blups$incon <- blups$congr + blups$stroop
# 
# blups.long <- full_join(
#   blups %>%
#     select(subj, congr, incon) %>%
#     reshape2::melt(variable.name = "trial.type", value.name = "rt"),
#   blups %>%
#     select(subj, lppc_R.target:vvis_L.incongruency) %>%
#     reshape2::melt(value.name = "beta"),
#   by = "subj"
# )
# 
# blups.long %>%
#   ggplot(aes(beta, rt, color = trial.type)) +
#   facet_grid(cols = vars(variable)) +
#   geom_smooth(
#     data = blups.long %>% filter(trial.type == "congr"), method = "lm", se = FALSE
#   ) +
#   geom_smooth(
#     data = blups.long %>% filter(trial.type == "incon"), method = "lm", se = FALSE
#   ) +
#   # stat_boot_ci(
#   #   data = blups.long %>% filter(trial.type == "incon"), alpha = 0.2
#   # ) +
#   # stat_boot_ci(
#   #   data = blups.long %>% filter(trial.type == "congr"), alpha = 0.2
#   # )
#   geom_point(alpha = 0.2) +
#   scale_color_brewer(type = "qual", palette = 2)
# # geom_line(aes(group = subj), color = "grey20")
# blups %>%
#   select(-congr, -incon) %>%
#   reshape2::melt(id.var = c("subj", "stroop")) %>%
#   ggplot(aes(value, stroop, color = variable)) +
#   facet_grid(cols = vars(variable)) +
#   geom_smooth(method = "lm", se = FALSE) +
#   geom_smooth(method = "lm", se = FALSE) +
#   stat_boot_ci(alpha = 0.3) +
#   # stat_boot_ci(
#   #   data = blups.long %>% filter(trial.type == "congr"), alpha = 0.2
#   # )
#   geom_point() +
#   scale_color_brewer(type = "qual", palette = 2)




```

## MDS

### setup

```{r mds_setup}

## setup ----

subjs <- blups$subj
n.subj <- length(subjs)
n.model <- length(mod.winning)
n.stim <- length(bias.items)

## get data

R <- readRDS(here("out", "rsa", "obsv", "rsarray_pro_bias_acc-only_masks_pearson_residual-linear.rds"))
dimnames(R)
R <- R[, , subjs, c("anatfunc_lppc_R", "anatfunc_mfc_L", "anatfunc_vvis_L", "anatfunc_dlpfc_L")]

```

### average geometries of 'winning' regions

```{r mds_average, fig.width = 15, fig.height = 4}

## mean matrices

Rbar <- apply(R, c(1:2, 4), function(x) tanh(mean(atanh(x))))  ## cross-subject average RSM per region
Dbar <- 1 - Rbar  ## same, but correlation distance

rois <- dimnames(Dbar)$roi
Mbar <- array(
  NA, 
  dim = c(stim = n.stim, dim = 2, roi = length(rois)), 
  dimnames = list(stim = bias.items, dims = c("MDS1", "MDS2"), roi = rois)
  )
p.mds.ave <- vector("list", length(rois)) %>% setNames(rois)
for (roi in rois) {
  
  Mbar[, , roi] <- Dbar[, , roi] %>% vegan::metaMDS(k = 2, trace = FALSE) %>% .$points
  
  p.mds.ave[[roi]] <- Dbar[, , roi] %>% 
    vegan::metaMDS(k = 2, trace = FALSE) %>% 
    .$points %>%
    mds.to.df %>% 
    plot.mds +
    labs(title = roi)
  
}
grid.arrange(p.mds.ave[[1]], p.mds.ave[[2]], p.mds.ave[[3]], p.mds.ave[[4]], ncol = 4)

```

### trichotomized by Stroop RT

```{r mds_trichotomy}

topthird <- w$subj[w$stroop < quantile(w$stroop, 1/3)]
midthird <- w$subj[w$stroop < quantile(w$stroop, 2/3) & w$stroop > quantile(w$stroop, 1/3)]
botthird <- w$subj[w$stroop > quantile(w$stroop, 2/3)]

par(mfrow = c(1, 1))
plot(
  w$stroop,
  pch = 16,
  col = ifelse(w$subj %in% topthird, "black", ifelse(w$subj %in% midthird, "orange", "firebrick")),
  main = "stroop RTs, split into 3 quantiles"
)

```

```{r mds_trichotomy_average, fig.width = 15, fig.height = 15}

Dbar.top <- 1 - R[, , topthird, ] %>% apply(c(".row", ".col", "roi"), function(x) tanh(mean(atanh(x))))
Dbar.mid <- 1 - R[, , midthird, ] %>% apply(c(".row", ".col", "roi"), function(x) tanh(mean(atanh(x))))
Dbar.bot <- 1 - R[, , botthird, ] %>% apply(c(".row", ".col", "roi"), function(x) tanh(mean(atanh(x))))

l.mrot.tri <- vector("list", length(rois))
p.mds.tri <- vector("list", length(rois)) %>% setNames(rois)
for (roi in rois) {
  
  Mbar.top <- metaMDS(Dbar.top[, , roi], k = 2, trace = FALSE)$points
  Mbar.mid <- metaMDS(Dbar.mid[, , roi], k = 2, trace = FALSE)$points
  Mbar.bot <- metaMDS(Dbar.bot[, , roi], k = 2, trace = FALSE)$points
  
  Mrot.tri <- rbind(
    procrustes(Mbar[, , roi], Mbar.top) %>% .$Yrot %>% reshape2::melt() %>% mutate(tri = "small_stroop"),
    procrustes(Mbar[, , roi], Mbar.mid) %>% .$Yrot %>% reshape2::melt() %>% mutate(tri = "mean_stroop"),
    procrustes(Mbar[, , roi], Mbar.bot) %>% .$Yrot %>% reshape2::melt() %>% mutate(tri = "large_stroop")
  )
  
  l.mrot.tri[[roi]] <- Mrot.tri %>%
    tidyr::spread(Var2, value) %>%
    rename(stim = Var1, MDS1 = "1", MDS2 = "2") %>%
    cbind(split.str.item(.$stim)) %>%
    mutate(roi = roi)
  
}

d.mrot.tri <- do.call(rbind, l.mrot.tri)

d.mrot.tri %>%
  ggplot(aes(x = MDS1, y = MDS2, fill = color)) +
  scale_fill_manual(values = c(blue = "blue", white = "grey40", red = "firebrick", purple = "purple")) +
  scale_color_manual(values = c(blue = "blue", white = "grey40", red = "firebrick", purple = "purple")) +
  geom_label(
    aes(label = word, color = color), fill = "white", fontface = "bold", label.size = 0
  ) +
  facet_grid(vars(roi), vars(tri), scales = "free") +
  theme(legend.position = "none")

```

### centroids and bootstrapped ellipses

```{r mds_trichotomy_boot, cache = TRUE}

n.resamples <- 1E3
l.mrot.boot <- vector("list", length(rois)) %>% setNames(rois)
set.seed(0)
time.beg <- Sys.time()
for (roi in rois) {
  
  mrot.boot <- vector("list", n.resamples)
  for (sample.i in seq_len(n.resamples)) {
  
    ## get resamples
    
    topthird.i <- sample(topthird, replace = TRUE)
    midthird.i <- sample(midthird, replace = TRUE)
    botthird.i <- sample(botthird, replace = TRUE)
  
    ## get stats
    
    D.top <- 1 - apply(R[, , topthird.i, roi], 1:2, function(x) tanh(mean(atanh(x))))
    D.mid <- 1 - apply(R[, , midthird.i, roi], 1:2, function(x) tanh(mean(atanh(x))))
    D.bot <- 1 - apply(R[, , botthird.i, roi], 1:2, function(x) tanh(mean(atanh(x))))

    M.top <- metaMDS(D.top, k = 2, trace = FALSE)$points
    M.mid <- metaMDS(D.mid, k = 2, trace = FALSE)$points
    M.bot <- metaMDS(D.bot, k = 2, trace = FALSE)$points
    
    mrot.boot[[sample.i]] <- rbind(
      M.mid %>% procrustes(Mbar[, , roi], ., scale = TRUE) %>% .$Yrot %>%
        data.frame(tri = "mid") %>%
        rename(MDS1 = "X1", MDS2 = "X2") %>%
        tibble::rownames_to_column("stim") %>%
        bind_cols(., split.str.item(.$stim)),
      M.top %>% procrustes(Mbar[, , roi], ., scale = TRUE) %>% .$Yrot %>%
        data.frame(tri = "top") %>%
        rename(MDS1 = "X1", MDS2 = "X2") %>%
        tibble::rownames_to_column("stim") %>%
        bind_cols(., split.str.item(.$stim)),
      M.bot %>% procrustes(Mbar[, , roi], ., scale = TRUE) %>% .$Yrot %>%
        data.frame(tri = "bot") %>%
        rename(MDS1 = "X1", MDS2 = "X2") %>%
        tibble::rownames_to_column("stim") %>%
        bind_cols(., split.str.item(.$stim))
    )
    
    mrot.boot[[sample.i]]$iter <- sample.i
    
  }
  
  l.mrot.boot[[roi]] <- mrot.boot
  
  print(roi)
  
}
(time.run <- Sys.time() - time.beg)

```



```{r mds_trichotomy_boot_plot, fig.width = 9, fig.height = 4, cache = TRUE}

## lppc

mrot.boot.lppc.l <- l.mrot.boot[[1]]
mrot.boot.lppc.l <- do.call(rbind, mrot.boot.lppc.l)

mrot.boot.lppc.l %>%
  mutate(
    color = as.character(color),
    tri = relevel(tri, "top")
  ) %>%
  group_by(iter, color, tri) %>%
  summarize(MDS1 = mean(MDS1), MDS2 = mean(MDS2)) %>%
  ggplot(aes(x = MDS1, y = MDS2, color = color)) +
  geom_point(alpha = 0.1, shape = 16) +
  geom_density_2d(size = 1) +
  scale_color_manual(values = c(blue = "blue", white = "grey40", red = "firebrick", purple = "purple")) +
  facet_grid(
    cols = vars(tri), 
    labeller = labeller(
      tri = c(top = "stroop < 1st tertile", mid = "1st tertile < stroop < 2nd tertile", bot = "2nd tertile < stroop")
    ) 
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.text =  element_blank(),
    axis.title = element_blank(),
    legend.position = "none"
  ) +
  labs(title = "right lppc, points are target centroids")


## mpfc

mrot.boot.mfc.l <- l.mrot.boot[[2]]
mrot.boot.mfc.l <- do.call(rbind, mrot.boot.mfc.l)

mrot.boot.mfc.l %>%
  mutate(
    congruency = as.character(congruency),
    tri = relevel(tri, "top")
  ) %>%
  group_by(iter, congruency, tri) %>%
  summarize(MDS1 = mean(MDS1), MDS2 = mean(MDS2)) %>%
  ggplot(aes(x = MDS1, y = MDS2, color = congruency)) +
  geom_point(alpha = 0.1, aes(fill = congruency), shape = 16) +
  geom_density_2d(size = 1) +
  scale_fill_brewer(type = "qual", palette = 2) +
  scale_color_brewer(type = "qual", palette = 2) +
  facet_grid(
    cols = vars(tri), 
    labeller = labeller(
      tri = c(top = "stroop RT < 1st tertile", mid = "1st tertile < stroop < 2nd tertile", bot = "2nd tertile < stroop")
    ) 
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.text =  element_blank(),
    axis.title = element_blank(),
    legend.position = "none"
  ) +
  labs(title = "left mpfc, points are congruent/incongruent centroids")

## vvis

mrot.boot.vvis.l <- l.mrot.boot[[1]]
mrot.boot.vvis.l <- do.call(rbind, mrot.boot.vvis.l)

mrot.boot.vvis.l %>%
   mutate(
    congruency = as.character(congruency),
    tri = relevel(tri, "top")
  ) %>%
  group_by(iter, congruency, tri) %>%
  summarize(MDS1 = mean(MDS1), MDS2 = mean(MDS2)) %>%
  ggplot(aes(x = MDS1, y = MDS2, color = congruency)) +
  geom_point(alpha = 0.1, aes(fill = congruency), shape = 16) +
  geom_density_2d(size = 1) +
  scale_fill_brewer(type = "qual", palette = 2) +
  scale_color_brewer(type = "qual", palette = 2) +
    facet_grid(
    cols = vars(tri), 
    labeller = labeller(
      tri = c(top = "stroop RT < 1st tertile", mid = "1st tertile < stroop < 2nd tertile", bot = "2nd tertile < stroop")
    ) 
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.text =  element_blank(),
    axis.title = element_blank(),
    legend.position = "none"
  ) +
  labs(title = "left vvc, points are congruent/incongruent centroids")


## dlpfc

mrot.boot.dlpfc.l <- l.mrot.boot[[4]]
mrot.boot.dlpfc.l <- do.call(rbind, mrot.boot.dlpfc.l)

mrot.boot.dlpfc.l %>%
   mutate(
    word = tolower(as.character(word)),
    # congruency = as.character(congruency),
    tri = relevel(tri, "top")
  ) %>%
  group_by(iter, word, tri) %>%
  summarize(MDS1 = mean(MDS1), MDS2 = mean(MDS2)) %>%
  ggplot(aes(x = MDS1, y = MDS2, color = word)) +
  geom_point(alpha = 0.1, aes(fill = word), shape = 16) +
  geom_density_2d(size = 1) +
  scale_color_manual(values = c(blue = "blue", white = "grey40", red = "firebrick", purple = "purple")) +
  facet_grid(
    cols = vars(tri), 
    labeller = labeller(
      tri = c(top = "stroop RT < 1st tertile", mid = "1st tertile < stroop < 2nd tertile", bot = "2nd tertile < stroop")
    ) 
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.text =  element_blank(),
    axis.title = element_blank(),
    legend.position = "none"
  ) +
  labs(title = "left dlpfc, points are distractor centroids")
  

```