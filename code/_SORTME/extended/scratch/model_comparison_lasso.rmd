---
title: "modeling stroop effects (RTs) with RSA coding schemes"
author: "michael freund"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 3
---

## about

```{r setup, include = FALSE}

library(mikeutils)
library(magrittr)
library(here)
library(knitr)
library(dplyr)
library(data.table)
library(ggplot2)
library(grid)
library(gridExtra)
library(colorspace)
library(viridis)
library(nlme)
library(caret)
library(gtools)
library(vegan)
library(glmnet)
library(selectiveInference)
library(stabs)
library(lars)

source(here("code", "strings.R"))

theme_set(theme_bw(base_size = 12))

## functions

split.str.item <- function(col.j, prefix = "") {
  ## takes a single "item" vector, e.g. "blueBLUE", and decomposes
  ## it into color ("blue") word ("BLUE"), congruency ("C"), and label 
  ## ("C.BLUE", for plotting). 
  # prefix <- paste0(col.j, ".")
  col.j      <- as.character(col.j)
  color      <- gsub("[A-Z]", "", col.j)
  word       <- gsub("[a-z]", "", col.j)
  congruency <- ifelse(color == tolower(word), "C", "I")
  label      <- paste0(congruency, ".", word)
  cols       <- as.data.frame(cbind(color, word, congruency, label))
  colnames(cols) <- paste0(prefix, c("color", "word", "congruency", "label"))
  return(cols)
}

mds.to.df <- function(mat) {
  mat %>%
    as.data.frame %>%
    tibble::rownames_to_column("stim") %>%
    bind_cols(., split.str.item(.$stim))
}

plot.mds <- function(df) {
  df %>%
    ggplot(aes(MDS1, MDS2)) +
    geom_label(aes(label = word, color = color), fill = "grey60", fontface = "bold", label.size = 0) +
    scale_color_manual(values = setNames(bias.colors, bias.colors)) +
    theme(
      panel.background = element_blank(), 
      axis.text = element_blank(), 
      legend.position = "none", 
      axis.ticks = element_blank()
    )
}


## strings

colors.model <- c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")


## read data

blups <- 
  bind_rows(
    read.csv(here("out", "behav", "stroop_blups_rt_group201902.csv"), stringsAsFactors = FALSE),
    read.csv(here("out", "behav", "stroop_blups_rt_group201902_validation.csv"), stringsAsFactors = FALSE) 
  )

stats.subjs.tdic <- bind_rows(
  superparcel = fread(
    here("out", "rsa", "stats", paste0("subjs_pro_bias_acc-only_masks_pearson_residual_glm-tdic.csv"))
    ),
  mmp = fread(
    here("out", "rsa", "stats", paste0("subjs_pro_bias_acc-only_mmp_pearson_residual_glm-tdic.csv"))
  ),
  .id = "scheme"
)

## subset and bind

stats.subjs.tdic <- stats.subjs.tdic[y == "rank" & param %in% c("target", "distractor", "incongruency"), ]
stats.subjs.tdic <- stats.subjs.tdic[, c("coef", "y", "model") := NULL]  ## remove useless cols
stats.subjs.tdic <- full_join(blups, stats.subjs.tdic, by = "subj")

## format cols (for superparcels)

stats.subjs.tdic <- cbind(
  stats.subjs.tdic,
  reshape2::colsplit(stats.subjs.tdic$roi, "_", c("roi.set", "superparcel"))
)
stats.subjs.tdic$superparcel[stats.subjs.tdic$superparcel == ""] <- "vwfa"

# stats.subjs.tdic <- stats.subjs.tdic[is.analysis.group == TRUE, ]  ## EXCLUDE HELD OUT SUBJECTS!

md <- list(
  core       = c("p9-46v", "a9-46v", "i6-8", "AVi", "8C", "IFJp", "IP2", "IP1", "PFm", "8BM", "SCEF"),
  extended   = c(
    "p9-46v", "a9-46v", "i6-8", "AVi", "8C", "IFJp", "IP2", "IP1", "PFm", "8BM",
    "TE1m", "TE1p", "PGs", "PFm", "AIP", "MIP", "LIPd", "IP1", "IP2", "s6-8", 
    "i6-8", "a9-46v", "FOP5", "AVI", "11l", "a10p", "p10p", "a47r", "p47r"
  )
)


w.mmp <- stats.subjs.tdic %>% 
  filter(scheme == "mmp") %>%
  ungroup %>%
  mutate(id = paste0(roi, "_", param)) %>%
  dplyr::select(subj, is.analysis.group, congr, stroop, beta, id) %>%
  tidyr::pivot_wider(names_from = "id", values_from = "beta")
ids <- w.mmp[c("subj", "is.analysis.group")]
w.mmp %<>% dplyr::select(-subj, -is.analysis.group) %>% as.matrix

w.anat <- stats.subjs.tdic %>% 
  filter(scheme == "superparcel", roi.set == "anat") %>%
  ungroup %>%
  mutate(id = paste0(superparcel, "_", param)) %>%
  dplyr::select(subj, is.analysis.group, congr, stroop, beta, id) %>%
  tidyr::pivot_wider(names_from = "id", values_from = "beta")
if (!identical(ids, w.anat[c("subj", "is.analysis.group")])) stop("something wrong")

w.anat %<>% dplyr::select(-subj, -is.analysis.group) %>% as.matrix

```


## superparcels

```{r}

names.anat <- colnames(w.anat)[-grep("stroop|subj|is.analysis.group|congr", colnames(w.anat))]

set.seed(0)

fit.anat.cv <- cv.glmnet(x = w.anat[ids$is.analysis.group, names.anat], w.anat[ids$is.analysis.group, "stroop"])
fit.anat <- glmnet(x = w.anat[ids$is.analysis.group, names.anat], w.anat[ids$is.analysis.group, "stroop"])
par(mfrow = c(1, 2))
plot(fit.anat.cv)
plot(fit.anat)
coef(fit.anat.cv, s = "lambda.min")
coef(fit.anat.cv, s = "lambda.1se")
coef(fit.anat.cv, s = mean(c(fit.anat.cv$lambda.min, fit.anat.cv$lambda.1se)))
coef(fit.anat.cv, s = max(fit.anat.cv$lambda))


## stability selection

set.seed(0)
fit.anat.stab <- stabsel(
  x = w.anat[ids$is.analysis.group, names.anat], 
  y = w.anat[ids$is.analysis.group, "stroop"],
  fitfun = glmnet.lasso, q = 3, PFER = 1
  )
fit.anat.stab
par(mfrow = c(1, 1))
plot(fit.anat.stab)

## take top three


## validation set error

yhat.md.core.lambda.mean <- predict(
  fit.md.core.cv, 
  s = mean(c(fit.md.core.cv$lambda.min, fit.md.core.cv$lambda.1se)), 
  newx = w.mmp[!ids$is.analysis.group, names.md.core]
  ) %>% c
yhat.md.core.lambda.max <- predict(
  fit.md.core.cv, 
  s = max(fit.md.core.cv$lambda), 
  newx = w.mmp[!ids$is.analysis.group, names.md.core]
  ) %>% c
yhat.md.core.lambda.min <- predict(
  fit.md.core.cv, 
  s = "lambda.min", 
  newx = w.mmp[!ids$is.analysis.group, names.md.core]
  ) %>% c

pred.md.core <- data.frame(
  y = w.mmp[!ids$is.analysis.group, "stroop"], 
  yhat.max = yhat.md.core.lambda.max,
  yhat.mean = yhat.md.core.lambda.mean,
  yhat.min = yhat.md.core.lambda.min
  )

wilcox.test(
  (pred.md.core$y - pred.md.core$yhat.min)^2 - (pred.md.core$y - pred.md.core$yhat.max)^2
)
sqrt(mean((pred.md.core$y - pred.md.core$yhat.min)^2))
sqrt(mean((pred.md.core$y - pred.md.core$yhat.max)^2))

pred.md.core %>%
  
  ggplot(aes(y, yhat.min)) +
  stat_boot_ci(n = 1e4, alpha = 0.5, color = "grey50") +
  geom_point()

cor(pred.md.core$y, pred.md.core$yhat.min)
cor(pred.md.core$y, pred.md.core$yhat.mean)



## robust to regression of congruent RT?

w.anat.resid <- resid(
    lm(
      w.anat[ids$is.analysis.group, c(names.anat, "stroop")] ~ w.anat[ids$is.analysis.group, "congr"]
    )
  )

set.seed(0)

fit.anat.congr.cv <- cv.glmnet(
  x = w.anat.resid[, names.anat], 
  w.anat.resid[, "stroop"]
  )
fit.anat.congr <- glmnet(
  x = w.anat.resid[, names.anat], 
  w.anat.resid[, "stroop"]
  )
par(mfrow = c(1, 2))
plot(fit.anat.congr.cv)
plot(fit.anat.congr)
coef(fit.anat.congr.cv, s = "lambda.min")
coef(fit.anat.congr.cv, s = "lambda.1se")
coef(fit.anat.congr.cv, s = mean(c(fit.anat.cv$lambda.min, fit.anat.cv$lambda.1se)))
coef(fit.anat.congr.cv, s = max(fit.anat.cv$lambda))


## stability selection

set.seed(0)
fit.anat.congr.stab <- stabsel(
  x = w.anat.resid[, names.anat], 
  y = w.anat.resid[, "stroop"],
  fitfun = glmnet.lasso, cutoff = 0.75, PFER = 2
  )
fit.anat.congr.stab
par(mfrow = c(1, 1))
plot(fit.anat.congr.stab)




```


## multiple-demand parcels

```{r}

## core ----

names.md.core <- colnames(w.mmp)[grep(paste0(md$core, collapse = "|"), colnames(w.mmp))]

set.seed(0)

fit.md.core.cv <- cv.glmnet(x = w.mmp[ids$is.analysis.group, names.md.core], w.mmp[ids$is.analysis.group, "stroop"])
fit.md.core <- glmnet(x = w.mmp[ids$is.analysis.group, names.md.core], w.mmp[ids$is.analysis.group, "stroop"])
par(mfrow = c(1, 2))
plot(fit.md.core.cv)
plot(fit.md.core)
coef(fit.md.core.cv, s = "lambda.min")
coef(fit.md.core.cv, s = "lambda.1se")
coef(fit.md.core.cv, s = mean(c(fit.md.core.cv$lambda.min, fit.md.core.cv$lambda.1se)))
coef(fit.md.core.cv, s = max(fit.md.core.cv$lambda))


## stability selection

set.seed(0)

fit.md.core.stab <- stabsel(
  x = w.mmp[ids$is.analysis.group, names.md.core], y = w.mmp[ids$is.analysis.group, "stroop"], fitfun = glmnet.lasso,
  cutoff = 0.6, PFER = 4
  )
fit.md.core.stab
par(mfrow = c(1, 1))
plot(fit.md.core.stab)


## validation set error

yhat.md.core.lambda.mean <- predict(
  fit.md.core.cv, 
  s = mean(c(fit.md.core.cv$lambda.min, fit.md.core.cv$lambda.1se)), 
  newx = w.mmp[!ids$is.analysis.group, names.md.core]
  ) %>% c
yhat.md.core.lambda.max <- predict(
  fit.md.core.cv, 
  s = max(fit.md.core.cv$lambda), 
  newx = w.mmp[!ids$is.analysis.group, names.md.core]
  ) %>% c
yhat.md.core.lambda.min <- predict(
  fit.md.core.cv, 
  s = "lambda.min", 
  newx = w.mmp[!ids$is.analysis.group, names.md.core]
  ) %>% c

pred.md.core <- data.frame(
  y = w.mmp[!ids$is.analysis.group, "stroop"], 
  yhat.max = yhat.md.core.lambda.max,
  yhat.mean = yhat.md.core.lambda.mean,
  yhat.min = yhat.md.core.lambda.min
  )

wilcox.test(
  (pred.md.core$y - pred.md.core$yhat.min)^2 - (pred.md.core$y - pred.md.core$yhat.max)^2
)
sqrt(mean((pred.md.core$y - pred.md.core$yhat.min)^2))
sqrt(mean((pred.md.core$y - pred.md.core$yhat.max)^2))

pred.md.core %>%
  
  ggplot(aes(y, yhat.min)) +
  stat_boot_ci(n = 1e4, alpha = 0.5, color = "grey50") +
  geom_point()

cor(pred.md.core$y, pred.md.core$yhat.min)
cor(pred.md.core$y, pred.md.core$yhat.mean)


# se.md.core.lambda.mean <- (w.mmp[!ids$is.analysis.group, "stroop"] - yhat.md.core.lambda.mean)^2
# sqrt(mean((w.mmp[!ids$is.analysis.group, "stroop"] - yhat.md.core.lambda.mean)^2))
# cor(w.mmp[!ids$is.analysis.group, "stroop"], yhat)
# plot(w.mmp[!ids$is.analysis.group, "stroop"], yhat)

## extended ----

names.md.exte <- colnames(w.mmp)[grep(paste0(md$extended, collapse = "|"), colnames(w.mmp))]


set.seed(0)

fit.md.exte.cv <- cv.glmnet(x = w.mmp[ids$is.analysis.group, names.md.exte], w.mmp[ids$is.analysis.group, "stroop"])
fit.md.exte <- glmnet(x = w.mmp[ids$is.analysis.group, names.md.exte], w.mmp[ids$is.analysis.group, "stroop"])
par(mfrow = c(1, 2))
plot(fit.md.exte.cv)
plot(fit.md.exte)
coef(fit.md.exte.cv, s = "lambda.min")
coef(fit.md.exte.cv, s = "lambda.1se")
coef(fit.md.exte.cv, s = mean(c(fit.md.exte.cv$lambda.min, fit.md.exte.cv$lambda.1se)))
coef(fit.md.exte.cv, s = max(fit.md.exte.cv$lambda))


## validation set error

yhat.md.exte.lambda.mean <- predict(
  fit.md.exte.cv, 
  s = mean(c(fit.md.exte.cv$lambda.min, fit.md.exte.cv$lambda.1se)), 
  newx = w.mmp[!ids$is.analysis.group, names.md.exte]
  ) %>% c
yhat.md.exte.lambda.max <- predict(
  fit.md.exte.cv, 
  s = max(fit.md.exte.cv$lambda), 
  newx = w.mmp[!ids$is.analysis.group, names.md.exte]
  ) %>% c
yhat.md.exte.lambda.min <- predict(
  fit.md.exte.cv, 
  s = "lambda.min", 
  newx = w.mmp[!ids$is.analysis.group, names.md.exte]
  ) %>% c

pred.md.exte <- data.frame(
  y = w.mmp[!ids$is.analysis.group, "stroop"], 
  yhat.max = yhat.md.exte.lambda.max,
  yhat.mean = yhat.md.exte.lambda.mean,
  yhat.min = yhat.md.exte.lambda.min
  )

wilcox.test(
  (pred.md.exte$y - pred.md.exte$yhat.min)^2 - (pred.md.exte$y - pred.md.exte$yhat.max)^2
)
sqrt(mean((pred.md.exte$y - pred.md.exte$yhat.min)^2))
sqrt(mean((pred.md.exte$y - pred.md.exte$yhat.mean)^2))
sqrt(mean((pred.md.exte$y - pred.md.exte$yhat.max)^2))

pred.md.exte %>%
  
  ggplot(aes(y, yhat.min)) +
  stat_boot_ci(n = 1e4, alpha = 0.5, color = "grey50") +
  geom_point()

cor(pred.md.exte$y, pred.md.exte$yhat.min)
cor(pred.md.exte$y, pred.md.exte$yhat.mean)
# cor(pred.md.exte$y, pred.md.exte$yhat.max)


set.seed(0)

fit.md.exte.stab <- stabsel(
  x = w.mmp[ids$is.analysis.group, names.md.exte], y = w.mmp[ids$is.analysis.group, "stroop"], fitfun = glmnet.lasso,
  cutoff = 0.6, PFER = 7
  )
fit.md.exte.stab
par(mfrow = c(1, 1))
plot(fit.md.exte.stab)


set.seed(0)
names.md.select <- c("p9-46v_L_distractor", "i6-8_R_target", "IP1_R_target")

fit.md.select.cv <- cv.glmnet(
  x = w.mmp[ids$is.analysis.group, names.md.select], 
  w.mmp[ids$is.analysis.group, "stroop"], 
  alpha = 0
  )
coef(fit.md.select.cv, s = "lambda.min")


yhat.md.select.lambda.mean <- predict(
  fit.md.select.cv, 
  s = mean(c(fit.md.select.cv$lambda.min, fit.md.select.cv$lambda.1se)), 
  newx = w.mmp[!ids$is.analysis.group, names.md.select]
  ) %>% c
yhat.md.select.lambda.max <- predict(
  fit.md.select.cv, 
  s = max(fit.md.select.cv$lambda), 
  newx = w.mmp[!ids$is.analysis.group, names.md.select]
  ) %>% c
yhat.md.select.lambda.min <- predict(
  fit.md.select.cv, 
  s = "lambda.min", 
  newx = w.mmp[!ids$is.analysis.group, names.md.select]
  ) %>% c

pred.md.select <- data.frame(
  y = w.mmp[!ids$is.analysis.group, "stroop"], 
  yhat.max = yhat.md.select.lambda.max,
  yhat.mean = yhat.md.select.lambda.mean,
  yhat.min = yhat.md.select.lambda.min
  )

wilcox.test(
  (pred.md.select$y - pred.md.select$yhat.min)^2 - (pred.md.select$y - pred.md.select$yhat.max)^2
)
sqrt(mean((pred.md.select$y - pred.md.select$yhat.min)^2))
sqrt(mean((pred.md.select$y - pred.md.select$yhat.mean)^2))
sqrt(mean((pred.md.select$y - pred.md.select$yhat.max)^2))

pred.md.select %>%
  
  ggplot(aes(y, yhat.min)) +
  stat_boot_ci(n = 1e4, alpha = 0.5, color = "grey50") +
  geom_point()

cor(pred.md.select$y, pred.md.select$yhat.min)
cor(pred.md.select$y, pred.md.select$yhat.mean)


data.frame(
  stroop = c(w.mmp[!ids$is.analysis.group, "stroop"]),
  subj = ids$subj[!ids$is.analysis.group]
)



```



```{r}

set.seed(0)

names.anat <- colnames(w.anat)[-grep("stroop|subj|is.analysis.group|congr", colnames(w.anat))]

fit.anat.cv <- cv.glmnet(x = w.anat[ids$is.analysis.group, names.anat], w.anat[ids$is.analysis.group, "stroop"])
fit.anat <- glmnet(x = w.anat[ids$is.analysis.group, names.anat], w.anat[ids$is.analysis.group, "stroop"])
# plot(fit.anat.cv)
coef(fit.anat.cv, s = "lambda.min")

yhat <- predict(fit.anat.cv, s = "lambda.min", newx = w.anat[!ids$is.analysis.group, names.anat])
sqrt(mean((w.anat[!ids$is.analysis.group, "stroop"] - yhat)^2))
cor(w.anat[!ids$is.analysis.group, "stroop"], yhat)
plot(w.anat[!ids$is.analysis.group, "stroop"], yhat)




# covariance test ----

all(svd(w.mmp[ids$is.analysis.group, names.md.exte])$d > 0)
path <- lar(w.mmp[ids$is.analysis.group, names.md.exte], w.mmp[ids$is.analysis.group, "stroop"])
(pathinf <- larInf(path))

names.md.exte[c(100, 118, 17)]



```













```{r optim-mse_plot, fig.width = 15}

# d <- d %>%
#   select(subj, congr, incon, superparcel, param, beta) %>%
#   as.data.table %>%
#   melt(value.name = "rt", id.vars = c("subj", "superparcel", "param", "beta"), measure.vars = c("congr", "incon"))

w.scale <- data.frame(scale(w[mod.winning]))

w.resid <- data.frame(
  dlpfc_L.distractor  = lm(lppc_R.target ~ ., w.scale)$resid,
  lppc_R.target       = lm(lppc_R.target ~ ., w.scale)$resid,
  mfc_L.incongruency  = lm(mfc_L.incongruency ~ ., w.scale)$resid,
  vvis_L.incongruency = lm(vvis_L.incongruency ~ ., w.scale)$resid
)

partials <- cbind(blups, w.resid)

cor(partials$stroop, partials$mfc_L.incongruency)
cor(partials$stroop, partials$lppc_R.target)
cor(partials$stroop, partials$vvis_L.incongruency)

par(mfrow = c(1, 4))
plot(partials$mfc_L.incongruency, partials$stroop, pch = 16)
plot(partials$lppc_R.target, partials$stroop, pch = 16)
plot(partials$vvis_L.incongruency, partials$stroop, pch = 16)
plot(partials$dlpfc_L.distractor, partials$stroop, pch = 16)


d.long <- stats.subjs.tdic %>% 
  filter(
    roi.set == "anatfunc", superparcel %in% c("mfc_L", "dlpfc_L", "vvis_L", "lppc_R")
    )
nsim <- 1E4
d.long %<>%
  mutate(
    is.selected.param = ifelse(
      (superparcel == "dlpfc_L" & param == "distractor") |
        (superparcel %in% c("vvis_L", "mfc_L") & param == "incongruency") |
        (superparcel == "lppc_R" & param == "target"), 
      TRUE,
      FALSE
    ),
    note.incon = ifelse(superparcel == "dlpfc_L" & param == "distractor", "incongruency", ""),
    note.targt = ifelse(superparcel == "dlpfc_L" & param == "distractor", "target", ""),
    note.distr = ifelse(superparcel == "dlpfc_L" & param == "distractor", "distractor", "")
  )
note.incon <- data.frame(
  superparcel = "dlpfc_L",
  param = "distractor",
  lab = "conflict"
)
note.distr <- data.frame(
  superparcel = "dlpfc_L",
  param = "distractor",
  lab = "distractor"
)
note.targt <- data.frame(
  superparcel = "dlpfc_L",
  param = "distractor",
  lab = "target"
)

plot.range <- d.long %>% 
  filter(superparcel %in% c("dlpfc_L", "vvis_L", "mfc_L", "lppc_L")) %>%
  summarize(
    max.stroop = max(stroop),
    min.stroop = min(stroop),
    min.beta = min(beta),
    max.beta = max(beta)
  )

d.long %>%
  ggplot(
    aes(beta, stroop, fill = param, color = param)
    ) +
  stat_boot_ci(aes(alpha = ifelse(is.selected.param, 0.4, 0.15)), n = nsim, color = "transparent") +
  geom_smooth(
    data = d.long %>% filter(is.selected.param),
    aes(alpha = ifelse(is.selected.param, 0.5, 0.1)), 
    method = "lm", se = FALSE
    ) +
  scale_alpha_identity() +
  geom_point(data = d.long %>% filter(is.selected.param), shape = 21, color = "white", size = 2) +
  facet_grid(cols = vars(superparcel)) +
  scale_color_manual(values = c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")) +
  scale_fill_manual(values = c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")) +
  theme_minimal(base_size = 15) +
  theme(
    axis.ticks       = element_line(),
    axis.text        = element_text(size = rel(0.5), color = "grey30"),
    # axis.text.y      = element_text(color = "transparent"),
    axis.title       = element_text(color = "grey30", face = "bold.italic"),
    # axis.title.y     = element_text(color = "transparent"),
    panel.background = element_blank(),
    panel.grid       =  element_blank(),
    legend.position  = "none",
    legend.direction = "horizontal",
    legend.title     = element_blank(),
    legend.text      = element_text(color = "grey30"),
    axis.line        = element_blank(),
    strip.background = element_blank(),
    strip.text       = element_text(face = "bold.italic", size = rel(0.75)),
    title            = element_text(face = "bold")
  ) +
  scale_x_continuous(
    breaks = c(plot.range$min.beta, 0, plot.range$max.beta) %>% round(2)
  ) +
  scale_y_continuous(
    breaks = c(plot.range$min.stroop, plot.range$max.stroop) %>% round(2)
  ) +
  geom_segment(
    aes(y = plot.range$min.stroop, yend = plot.range$max.stroop, x = -Inf, xend = -Inf),
    color = "grey50", size = 0.25
    ) +
  geom_segment(
      aes(x = plot.range$min.beta, xend = plot.range$max.beta, y = -Inf, yend = -Inf),
      color = "grey50", size = 0.25
      ) +
  labs(x = "RSA model fit (beta)", y = "Stroop effect (RT)", title = "a") +
  geom_text(
    data = note.incon, aes(label = lab), color = colors.model["incongruency"], x = -Inf, y = 10, 
    fontface = "bold", vjust = 0, hjust = 0
    ) +
  geom_text(
    data = note.targt, aes(label = lab), color = colors.model["target"], x = -Inf, y = 20, 
    fontface = "bold", vjust = 0, hjust = 0
    ) +
  geom_text(
    data = note.distr, aes(label = lab), color = colors.model["distractor"], x = -Inf, y = 30, 
    fontface = "bold", vjust = 0, hjust = 0
    )



p.selected.model <- d.long %>%
  filter(is.selected.param) %>%
  ggplot(
    aes(beta, stroop, fill = param, color = param)
    ) +
  stat_boot_ci(alpha = 0.4, n = nsim, color = "transparent") +
  geom_smooth(
    alpha = 0.5,
    # data = d.long %>% filter(is.selected.param),
    # aes(alpha = ifelse(is.selected.param, 0.5, 0.1)), 
    method = "lm", se = FALSE
    ) +
  # scale_alpha_identity() +
  geom_point(data = d.long %>% filter(is.selected.param), shape = 21, color = "white", size = 2) +
  facet_grid(cols = vars(superparcel)) +
  scale_color_manual(values = c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")) +
  scale_fill_manual(values = c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")) +
  theme_minimal(base_size = 15) +
  theme(
    axis.ticks       = element_line(),
    axis.text        = element_text(size = rel(0.5), color = "grey30"),
    # axis.text.y      = element_text(color = "transparent"),
    axis.title       = element_text(color = "grey30", face = "bold.italic"),
    # axis.title.y     = element_text(color = "transparent"),
    panel.background = element_blank(),
    panel.grid       =  element_blank(),
    legend.position  = "none",
    legend.direction = "horizontal",
    legend.title     = element_blank(),
    legend.text      = element_text(color = "grey30"),
    axis.line        = element_blank(),
    strip.background = element_blank(),
    strip.text       = element_text(face = "bold.italic", size = rel(0.75)),
    title            = element_text(face = "bold")
  ) +
  scale_x_continuous(
    breaks = c(plot.range$min.beta, 0, plot.range$max.beta) %>% round(2)
  ) +
  scale_y_continuous(
    breaks = c(plot.range$min.stroop, plot.range$max.stroop) %>% round(2)
  ) +
  geom_segment(
    aes(y = plot.range$min.stroop, yend = plot.range$max.stroop, x = -Inf, xend = -Inf),
    color = "grey50", size = 0.25
    ) +
  geom_segment(
      aes(x = plot.range$min.beta, xend = plot.range$max.beta, y = -Inf, yend = -Inf),
      color = "grey50", size = 0.25
      ) +
  labs(x = "RSA model fit (beta)", y = "Stroop effect (RT)", title = "a") +
  geom_text(
    data = note.incon, aes(label = lab), color = colors.model["incongruency"], x = -Inf, y = 10, 
    fontface = "bold", vjust = 0, hjust = 0
    ) +
  geom_text(
    data = note.targt, aes(label = lab), color = colors.model["target"], x = -Inf, y = 20, 
    fontface = "bold", vjust = 0, hjust = 0
    ) +
  geom_text(
    data = note.distr, aes(label = lab), color = colors.model["distractor"], x = -Inf, y = 30, 
    fontface = "bold", vjust = 0, hjust = 0
    )

p.selected.model

ggsave(
  here("out", "figs", "ms_v1_2020-03", "indif_explor", "indif_explor.pdf"), 
  plot = p.selected.model,
  units = "cm",
  device = "pdf",
  height = 9,
  width = 9 * 3
)


p.additional <- d.long %>%
  filter(is.selected.param, roi %in% c("anatfunc_vvis_L", "anatfunc_dlpfc_L")) %>%
  ggplot(
    aes(beta, stroop, fill = param, color = param)
    ) +
  stat_boot_ci(alpha = 0.4, n = nsim, color = "transparent") +
  geom_smooth(
    alpha = 0.5,
    # data = d.long %>% filter(is.selected.param),
    # aes(alpha = ifelse(is.selected.param, 0.5, 0.1)), 
    method = "lm", se = FALSE
    ) +
  # scale_alpha_identity() +
  geom_point(data = d.long %>% filter(is.selected.param, roi %in% c("anatfunc_vvis_L", "anatfunc_dlpfc_L")), shape = 21, color = "white", size = 2) +
  facet_grid(cols = vars(superparcel)) +
  scale_color_manual(values = c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")) +
  scale_fill_manual(values = c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")) +
  theme_minimal(base_size = 15) +
  theme(
    axis.ticks       = element_line(),
    axis.text        = element_text(size = rel(0.5), color = "grey30"),
    # axis.text.y      = element_text(color = "transparent"),
    axis.title       = element_text(color = "grey30", face = "bold.italic"),
    # axis.title.y     = element_text(color = "transparent"),
    panel.background = element_blank(),
    panel.grid       =  element_blank(),
    legend.position  = "none",
    legend.direction = "horizontal",
    legend.title     = element_blank(),
    legend.text      = element_text(color = "grey30"),
    axis.line        = element_blank(),
    strip.background = element_blank(),
    strip.text       = element_text(face = "bold.italic", size = rel(0.75)),
    title            = element_text(face = "bold")
  ) +
  scale_x_continuous(
    breaks = c(plot.range$min.beta, 0, plot.range$max.beta) %>% round(2)
  ) +
  scale_y_continuous(
    breaks = c(plot.range$min.stroop, plot.range$max.stroop) %>% round(2)
  ) +
  geom_segment(
    aes(y = plot.range$min.stroop, yend = plot.range$max.stroop, x = -Inf, xend = -Inf),
    color = "grey50", size = 0.25
    ) +
  geom_segment(
      aes(x = plot.range$min.beta, xend = plot.range$max.beta, y = -Inf, yend = -Inf),
      color = "grey50", size = 0.25
      ) +
  labs(x = "RSA model fit (beta)", y = "Stroop effect (RT)") +
  geom_text(
    data = note.incon, aes(label = lab), color = colors.model["incongruency"], x = -Inf, y = 10, 
    fontface = "bold", vjust = 0, hjust = 0
    ) +
  geom_text(
    data = note.distr, aes(label = lab), color = colors.model["distractor"], x = -Inf, y = 30, 
    fontface = "bold", vjust = 0, hjust = 0
    )

ggsave(
  here("out", "figs", "ms_v1_2020-03", "indif_explor", "fig_indif_explor_additional.pdf"), 
  plot = p.additional,
  units = "cm",
  device = "pdf",
  height = 7,
  width = 8 * 2
)


```

## testing hypotheses in MLM

* tested via cross-level interaction between fit to coding scheme and trial type

```{r mlm, cache = TRUE}

## fit MLM

fit <- readRDS(here("out", "behav", "fit1-het-trim_group201902.RDS"))
behav <- fit$data
behav %<>% full_join(cbind(subj = w$subj, w.scale), by = "subj")

fit.win <- lme(
  scale(rt) ~ trial.type + lppc_R.target + mfc_L.incongruency + vvis_L.incongruency + dlpfc_L.distractor +
    trial.type:lppc_R.target +
    trial.type:mfc_L.incongruency +
    trial.type:vvis_L.incongruency +
    trial.type:dlpfc_L.distractor,
  random  = ~ trial.type | subj,
  data    = behav,
  weights = varIdent(form = ~ 1 | subj),
  control = lmeControl(maxIter = 1e5, msMaxIter = 1e5, niterEM = 1e5, msMaxEval = 1e5),
  method  = "REML"
)

summary(fit.win)
# intervals(fit.winning, which = "fixed")


## TODO: set up double dissociation
# fit.pfc <- lme(
#   scale(rt) ~ trial.type * scheme * region,
#   random  = ~ trial.type | subj,
#   data    = behav,
#   weights = varIdent(form = ~ 1 | subj),
#   control = lmeControl(maxIter = 1e5, msMaxIter = 1e5, niterEM = 1e5, msMaxEval = 1e5),
#   method  = "REML"
# )


# ## plot: MLM
# 
# blups$incon <- blups$congr + blups$stroop
# 
# blups.long <- full_join(
#   blups %>%
#     select(subj, congr, incon) %>%
#     reshape2::melt(variable.name = "trial.type", value.name = "rt"),
#   blups %>%
#     select(subj, lppc_R.target:vvis_L.incongruency) %>%
#     reshape2::melt(value.name = "beta"),
#   by = "subj"
# )
# 
# blups.long %>%
#   ggplot(aes(beta, rt, color = trial.type)) +
#   facet_grid(cols = vars(variable)) +
#   geom_smooth(
#     data = blups.long %>% filter(trial.type == "congr"), method = "lm", se = FALSE
#   ) +
#   geom_smooth(
#     data = blups.long %>% filter(trial.type == "incon"), method = "lm", se = FALSE
#   ) +
#   # stat_boot_ci(
#   #   data = blups.long %>% filter(trial.type == "incon"), alpha = 0.2
#   # ) +
#   # stat_boot_ci(
#   #   data = blups.long %>% filter(trial.type == "congr"), alpha = 0.2
#   # )
#   geom_point(alpha = 0.2) +
#   scale_color_brewer(type = "qual", palette = 2)
# # geom_line(aes(group = subj), color = "grey20")
# blups %>%
#   select(-congr, -incon) %>%
#   reshape2::melt(id.var = c("subj", "stroop")) %>%
#   ggplot(aes(value, stroop, color = variable)) +
#   facet_grid(cols = vars(variable)) +
#   geom_smooth(method = "lm", se = FALSE) +
#   geom_smooth(method = "lm", se = FALSE) +
#   stat_boot_ci(alpha = 0.3) +
#   # stat_boot_ci(
#   #   data = blups.long %>% filter(trial.type == "congr"), alpha = 0.2
#   # )
#   geom_point() +
#   scale_color_brewer(type = "qual", palette = 2)




```

## MDS

### setup

```{r mds_setup}

## setup ----

subjs <- blups$subj
n.subj <- length(subjs)
n.model <- length(mod.winning)
n.stim <- length(bias.items)

## get data

R <- readRDS(here("out", "rsa", "obsv", "rsarray_pro_bias_acc-only_masks_pearson_residual-linear.rds"))
dimnames(R)
R <- R[, , subjs, c("anatfunc_lppc_R", "anatfunc_mfc_L", "anatfunc_vvis_L", "anatfunc_dlpfc_L")]

```

### average geometries of 'winning' regions

```{r mds_average, fig.width = 15, fig.height = 4}

## mean matrices

Rbar <- apply(R, c(1:2, 4), function(x) tanh(mean(atanh(x))))  ## cross-subject average RSM per region
Dbar <- 1 - Rbar  ## same, but correlation distance

rois <- dimnames(Dbar)$roi
Mbar <- array(
  NA, 
  dim = c(stim = n.stim, dim = 2, roi = length(rois)), 
  dimnames = list(stim = bias.items, dims = c("MDS1", "MDS2"), roi = rois)
  )
p.mds.ave <- vector("list", length(rois)) %>% setNames(rois)
for (roi in rois) {
  
  Mbar[, , roi] <- Dbar[, , roi] %>% vegan::metaMDS(k = 2, trace = FALSE) %>% .$points
  
  p.mds.ave[[roi]] <- Dbar[, , roi] %>% 
    vegan::metaMDS(k = 2, trace = FALSE) %>% 
    .$points %>%
    mds.to.df %>% 
    plot.mds +
    labs(title = roi)
  
}
grid.arrange(p.mds.ave[[1]], p.mds.ave[[2]], p.mds.ave[[3]], p.mds.ave[[4]], ncol = 4)

```

### trichotomized by Stroop RT

```{r mds_trichotomy}

topthird <- w$subj[w$stroop < quantile(w$stroop, 1/3)]
midthird <- w$subj[w$stroop < quantile(w$stroop, 2/3) & w$stroop > quantile(w$stroop, 1/3)]
botthird <- w$subj[w$stroop > quantile(w$stroop, 2/3)]

par(mfrow = c(1, 1))
plot(
  w$stroop,
  pch = 16,
  col = ifelse(w$subj %in% topthird, "black", ifelse(w$subj %in% midthird, "orange", "firebrick")),
  main = "stroop RTs, split into 3 quantiles"
)

```

```{r mds_trichotomy_average, fig.width = 15, fig.height = 15}

Dbar.top <- 1 - R[, , topthird, ] %>% apply(c(".row", ".col", "roi"), function(x) tanh(mean(atanh(x))))
Dbar.mid <- 1 - R[, , midthird, ] %>% apply(c(".row", ".col", "roi"), function(x) tanh(mean(atanh(x))))
Dbar.bot <- 1 - R[, , botthird, ] %>% apply(c(".row", ".col", "roi"), function(x) tanh(mean(atanh(x))))

l.mrot.tri <- vector("list", length(rois))
p.mds.tri <- vector("list", length(rois)) %>% setNames(rois)
for (roi in rois) {
  
  Mbar.top <- metaMDS(Dbar.top[, , roi], k = 2, trace = FALSE)$points
  Mbar.mid <- metaMDS(Dbar.mid[, , roi], k = 2, trace = FALSE)$points
  Mbar.bot <- metaMDS(Dbar.bot[, , roi], k = 2, trace = FALSE)$points
  
  Mrot.tri <- rbind(
    procrustes(Mbar[, , roi], Mbar.top) %>% .$Yrot %>% reshape2::melt() %>% mutate(tri = "small_stroop"),
    procrustes(Mbar[, , roi], Mbar.mid) %>% .$Yrot %>% reshape2::melt() %>% mutate(tri = "mean_stroop"),
    procrustes(Mbar[, , roi], Mbar.bot) %>% .$Yrot %>% reshape2::melt() %>% mutate(tri = "large_stroop")
  )
  
  l.mrot.tri[[roi]] <- Mrot.tri %>%
    tidyr::spread(Var2, value) %>%
    rename(stim = Var1, MDS1 = "1", MDS2 = "2") %>%
    cbind(split.str.item(.$stim)) %>%
    mutate(roi = roi)
  
}

d.mrot.tri <- do.call(rbind, l.mrot.tri)

d.mrot.tri %>%
  ggplot(aes(x = MDS1, y = MDS2, fill = color)) +
  scale_fill_manual(values = c(blue = "blue", white = "grey40", red = "firebrick", purple = "purple")) +
  scale_color_manual(values = c(blue = "blue", white = "grey40", red = "firebrick", purple = "purple")) +
  geom_label(
    aes(label = word, color = color), fill = "white", fontface = "bold", label.size = 0
  ) +
  facet_grid(vars(roi), vars(tri), scales = "free") +
  theme(legend.position = "none")

```

### centroids and bootstrapped ellipses

```{r mds_trichotomy_boot, cache = TRUE}

n.resamples <- 1E3
l.mrot.boot <- vector("list", length(rois)) %>% setNames(rois)
set.seed(0)
time.beg <- Sys.time()
for (roi in rois) {
  
  mrot.boot <- vector("list", n.resamples)
  for (sample.i in seq_len(n.resamples)) {
  
    ## get resamples
    
    topthird.i <- sample(topthird, replace = TRUE)
    midthird.i <- sample(midthird, replace = TRUE)
    botthird.i <- sample(botthird, replace = TRUE)
  
    ## get stats
    
    D.top <- 1 - apply(R[, , topthird.i, roi], 1:2, function(x) tanh(mean(atanh(x))))
    D.mid <- 1 - apply(R[, , midthird.i, roi], 1:2, function(x) tanh(mean(atanh(x))))
    D.bot <- 1 - apply(R[, , botthird.i, roi], 1:2, function(x) tanh(mean(atanh(x))))

    M.top <- metaMDS(D.top, k = 2, trace = FALSE)$points
    M.mid <- metaMDS(D.mid, k = 2, trace = FALSE)$points
    M.bot <- metaMDS(D.bot, k = 2, trace = FALSE)$points
    
    mrot.boot[[sample.i]] <- rbind(
      M.mid %>% procrustes(Mbar[, , roi], ., scale = TRUE) %>% .$Yrot %>%
        data.frame(tri = "mid") %>%
        rename(MDS1 = "X1", MDS2 = "X2") %>%
        tibble::rownames_to_column("stim") %>%
        bind_cols(., split.str.item(.$stim)),
      M.top %>% procrustes(Mbar[, , roi], ., scale = TRUE) %>% .$Yrot %>%
        data.frame(tri = "top") %>%
        rename(MDS1 = "X1", MDS2 = "X2") %>%
        tibble::rownames_to_column("stim") %>%
        bind_cols(., split.str.item(.$stim)),
      M.bot %>% procrustes(Mbar[, , roi], ., scale = TRUE) %>% .$Yrot %>%
        data.frame(tri = "bot") %>%
        rename(MDS1 = "X1", MDS2 = "X2") %>%
        tibble::rownames_to_column("stim") %>%
        bind_cols(., split.str.item(.$stim))
    )
    
    mrot.boot[[sample.i]]$iter <- sample.i
    
  }
  
  l.mrot.boot[[roi]] <- mrot.boot
  
  print(roi)
  
}
(time.run <- Sys.time() - time.beg)

```



```{r mds_trichotomy_boot_plot, fig.width = 9, fig.height = 4, cache = TRUE}

## lppc

mrot.boot.lppc.l <- l.mrot.boot[[1]]
mrot.boot.lppc.l <- do.call(rbind, mrot.boot.lppc.l)

mrot.boot.lppc.l %>%
  mutate(
    color = as.character(color),
    tri = relevel(tri, "top")
  ) %>%
  group_by(iter, color, tri) %>%
  summarize(MDS1 = mean(MDS1), MDS2 = mean(MDS2)) %>%
  ggplot(aes(x = MDS1, y = MDS2, color = color)) +
  geom_point(alpha = 0.1, shape = 16) +
  geom_density_2d(size = 1) +
  scale_color_manual(values = c(blue = "blue", white = "grey40", red = "firebrick", purple = "purple")) +
  facet_grid(
    cols = vars(tri), 
    labeller = labeller(
      tri = c(top = "stroop < 1st tertile", mid = "1st tertile < stroop < 2nd tertile", bot = "2nd tertile < stroop")
    ) 
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.text =  element_blank(),
    axis.title = element_blank(),
    legend.position = "none"
  ) +
  labs(title = "right lppc, points are target centroids")


## mpfc

mrot.boot.mfc.l <- l.mrot.boot[[2]]
mrot.boot.mfc.l <- do.call(rbind, mrot.boot.mfc.l)

mrot.boot.mfc.l %>%
  mutate(
    congruency = as.character(congruency),
    tri = relevel(tri, "top")
  ) %>%
  group_by(iter, congruency, tri) %>%
  summarize(MDS1 = mean(MDS1), MDS2 = mean(MDS2)) %>%
  ggplot(aes(x = MDS1, y = MDS2, color = congruency)) +
  geom_point(alpha = 0.1, aes(fill = congruency), shape = 16) +
  geom_density_2d(size = 1) +
  scale_fill_brewer(type = "qual", palette = 2) +
  scale_color_brewer(type = "qual", palette = 2) +
  facet_grid(
    cols = vars(tri), 
    labeller = labeller(
      tri = c(top = "stroop RT < 1st tertile", mid = "1st tertile < stroop < 2nd tertile", bot = "2nd tertile < stroop")
    ) 
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.text =  element_blank(),
    axis.title = element_blank(),
    legend.position = "none"
  ) +
  labs(title = "left mpfc, points are congruent/incongruent centroids")

## vvis

mrot.boot.vvis.l <- l.mrot.boot[[1]]
mrot.boot.vvis.l <- do.call(rbind, mrot.boot.vvis.l)

mrot.boot.vvis.l %>%
   mutate(
    congruency = as.character(congruency),
    tri = relevel(tri, "top")
  ) %>%
  group_by(iter, congruency, tri) %>%
  summarize(MDS1 = mean(MDS1), MDS2 = mean(MDS2)) %>%
  ggplot(aes(x = MDS1, y = MDS2, color = congruency)) +
  geom_point(alpha = 0.1, aes(fill = congruency), shape = 16) +
  geom_density_2d(size = 1) +
  scale_fill_brewer(type = "qual", palette = 2) +
  scale_color_brewer(type = "qual", palette = 2) +
    facet_grid(
    cols = vars(tri), 
    labeller = labeller(
      tri = c(top = "stroop RT < 1st tertile", mid = "1st tertile < stroop < 2nd tertile", bot = "2nd tertile < stroop")
    ) 
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.text =  element_blank(),
    axis.title = element_blank(),
    legend.position = "none"
  ) +
  labs(title = "left vvc, points are congruent/incongruent centroids")


## dlpfc

mrot.boot.dlpfc.l <- l.mrot.boot[[4]]
mrot.boot.dlpfc.l <- do.call(rbind, mrot.boot.dlpfc.l)

mrot.boot.dlpfc.l %>%
   mutate(
    word = tolower(as.character(word)),
    # congruency = as.character(congruency),
    tri = relevel(tri, "top")
  ) %>%
  group_by(iter, word, tri) %>%
  summarize(MDS1 = mean(MDS1), MDS2 = mean(MDS2)) %>%
  ggplot(aes(x = MDS1, y = MDS2, color = word)) +
  geom_point(alpha = 0.1, aes(fill = word), shape = 16) +
  geom_density_2d(size = 1) +
  scale_color_manual(values = c(blue = "blue", white = "grey40", red = "firebrick", purple = "purple")) +
  facet_grid(
    cols = vars(tri), 
    labeller = labeller(
      tri = c(top = "stroop RT < 1st tertile", mid = "1st tertile < stroop < 2nd tertile", bot = "2nd tertile < stroop")
    ) 
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    axis.text =  element_blank(),
    axis.title = element_blank(),
    legend.position = "none"
  ) +
  labs(title = "left dlpfc, points are distractor centroids")
  

```