---
title: "modeling stroop effects (RTs) with RSA coding schemes"
author: "michael freund"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
    theme: spacelab
    highlight: zenburn
---

```{r setup, include = FALSE}

## setup ----

library(mikeutils)
library(magrittr)
library(here)
library(knitr)
library(data.table)
library(ggplot2)
library(grid)
library(gridExtra)
library(colorspace)
library(viridis)
library(nlme)
library(caret)
library(gtools)
library(vegan)
library(glmnet)
library(selectiveInference)
library(stabs)
library(lars)
library(dplyr)
library(tidyr)
library(foreach)
library(doParallel)
library(doRNG)
library(WRS2)
library(boot)
library(multcomp)
library(lme4)
library(lmerTest)
library(nlme)
library(lemon)
library(cowplot)
source(here("code", "strings.R"))
source(here("code", "funs.R"))


## global settings


theme_set(theme_bw(base_size = 12))
n_cores <- detectCores()
nreps <- 5E3
nresamps <- 1E4

axis.text.size <- rel(1)
axis.title.size <- rel(1)
axis.line.size <- rel(1)
label.size <- rel(3)
p.value.size <- rel(2)
p.line.size <- rel(0.5)
geom.line.size <- rel(1)
geom.point.size <- rel(2)


## strings


colors.model <- c(incongruency = "#d95f02", target = "#1b9e77", distractor = "#7570b3")

md <- list(
  core       = c("p9-46v", "a9-46v", "i6-8", "AVI", "8C", "IFJp", "IP2", "IP1", "PFm", "8BM", "SCEF"),
  extended   = c(
    "p9-46v", "a9-46v", "i6-8", "AVi", "8C", "IFJp", "IP2", "IP1", "PFm", "8BM",
    "TE1m", "TE1p", "PGs", "PFm", "AIP", "MIP", "LIPd", "IP1", "IP2", "s6-8", 
    "i6-8", "a9-46v", "FOP5", "AVI", "11l", "a10p", "p10p", "a47r", "p47r"
  )
)

hyps <- combo_paste(c("dlpfc", "lppc", "dmfc"), c("R", "L"), c("target", "incongruency"))


## data

behav.mod.objs <- readRDS(here("out", "behav", "mod_objs.RDS"))  ## behavioral model objects
names(behav.mod.objs) <- c("fit1.het.trim", "er.stroopvar", "rt.stroopvar", "rt.hom.v.het", "r.marginal.trim", "u.trim")

blups <- 
  bind_rows(
    read.csv(here("out", "behav", "stroop_blups_rt_group201902.csv"), stringsAsFactors = FALSE),
    read.csv(here("out", "behav", "stroop_blups_rt_group201902_validation.csv"), stringsAsFactors = FALSE) 
  )

stats.subjs.tdic <- bind_rows(
  
  mmp =
    fread(
      here("out", "rsa", "stats", paste0("subjs_pro_bias_acc-only_mmp_pearson_residual_glm-tdic.csv"))
      ) %>% 
    filter(y == "rank", param %in% c("target", "distractor", "incongruency")),
  
  superparcel = 
    fread(
      here("out", "rsa", "stats", paste0("subjs_pro_bias_acc-only_masks_pearson_residual_glm-tdic.csv"))
      ) %>% 
    filter(y == "rank", param %in% c("target", "distractor", "incongruency"), roi != "V1"),
  
  .id = "scheme"
  
) %>% as.data.table

superparcels <- stats.subjs.tdic %>% filter(scheme == "superparcel") %>% pull(roi) %>% unique

## subset and bind

stats.subjs.tdic <- stats.subjs.tdic[y == "rank" & param %in% c("target", "distractor", "incongruency"), ]
stats.subjs.tdic <- stats.subjs.tdic[, c("coef", "y", "model") := NULL]  ## remove useless cols
stats.subjs.tdic <- full_join(blups, stats.subjs.tdic, by = "subj")
stats.subjs.tdic %<>% ungroup %>% mutate(id = paste0(roi, "_", param))


## define data.frames (long form)

d.mmp <- stats.subjs.tdic %>% filter(scheme == "mmp")
d.super <- stats.subjs.tdic %>% filter(scheme == "superparcel")


## define matrices for model selection
## "w" indicates wide format


w.mmp <- stats.subjs.tdic %>% 
  
  filter(scheme == "mmp") %>%
  
  dplyr::select(subj, is.analysis.group, congr, stroop, beta, id) %>%
  pivot_wider(names_from = "id", values_from = "beta")


w.super <- stats.subjs.tdic %>% 
  
  filter(scheme == "superparcel") %>%
  
  dplyr::select(subj, is.analysis.group, congr, stroop, beta, id) %>%
  pivot_wider(names_from = "id", values_from = "beta")

## convert to numeric matrix, extract matrix of ID info

are.identical <- identical(w.mmp[c("subj", "is.analysis.group")], w.super[c("subj", "is.analysis.group")])
if (!are.identical) {
  stop("something wrong")
} else {
  
  ids <- w.mmp[c("subj", "is.analysis.group")]
  
  m.mmp <- w.mmp %>% ungroup %>% dplyr::select(-subj, -is.analysis.group, -scheme) %>% as.matrix
  m.super <- w.super %>% ungroup %>%  dplyr::select(-subj, -is.analysis.group, -scheme) %>% as.matrix
  
}

## response variables

strooprt <- as.matrix(w.super[ids$is.analysis.group, "stroop"])
strooprt_p <- m.super[!ids$is.analysis.group, "stroop"]

```


# prelim validation analyses


```{r}

## read if file exists, source if not
behav.mod.objs <- readRDS(here("out", "behav", "mod_objs.RDS"))
names(behav.mod.objs) <- c("fit1.het.trim", "er.stroopvar", "rt.stroopvar", "rt.hom.v.het", "r.marginal.trim", "u.trim")

```



# hypothesis-driven analysis

* create bivariate scatterplots:
    * fig-indiv panel A
    * fig-indiv-hyp-bivar
* create table of stats
    * table-indiv-hyp-sep
    * table-indiv-hyp-all

## bivariate correlations, scatterplots

```{r}

## correlations ----

set.seed(0)

cors <- d.super %>%
  
  filter(is.analysis.group, id %in% hyps) %>%
   
  group_by(id) %>%
  
  summarize(
    r.line = cor(beta, stroop),
    r.rank = cor(beta, stroop, method = "spearman"),
    r2.line = r.line^2,
    r2.rank = r.rank^2
  )

## get confidence intervals

l <- d.super %>%
  
  filter(is.analysis.group, id %in% hyps) %>%
  group_by(id) %>%
  split(f = .$id) %>%
  purrr::map(~.[c("stroop", "beta")])

ci.line <- lapply(l, cor_ci) %>% bind_rows
ci.rank <- lapply(l, cor_ci, method = "spearman") %>% bind_rows

names(ci.line) %<>% paste0("_line")
names(ci.rank) %<>% paste0("_rank")

cors <- bind_cols(cors, ci.line, ci.rank)
cors$p.geq0_line <- 1 - cors$p.leq0_line
cors$p.geq0_rank <- 1 - cors$p.leq0_rank

kable(cors %>% arrange(-r2.line), digits = 2)

fwrite(cors, here("out", "indiv", "hyp_bivariate.txt"))


## plot ----

p.allcors <- d.super %>%
  
  mutate(
    hemi   = gsub("(.*)_(L|R)", "\\2", roi),
    region = gsub("(.*)_(L|R)", "\\1", roi) %>% toupper
    ) %>%
  
  filter(region %in% c("DLPFC", "DMFC", "LPPC"), param %in% c("target", "incongruency")) %>%
  
  ggplot(aes(beta, stroop, fill = param, color = param)) +
  
  stat_boot_ci(n = 1E4, alpha = 0.3, color = "transparent") +
  geom_smooth(method = "lm", se = FALSE) +
  geom_point(color = "white", shape = 21, size = geom.point.size/2) +
  
  scale_fill_manual(values = colors.model) +
  scale_color_manual(values = colors.model) +

  facet_grid(vars(hemi), vars(region)) +
  
  coord_capped_cart(left = "both", bottom = "both") +
  scale_y_continuous(limits = c(0, 150)) +
  scale_x_continuous(limits = c(-0.45, 0.65), breaks = c(-0.4, 0, 0.6)) +
  
  theme(
    panel.grid      = element_blank(),
    panel.border    = element_blank(),
    # panel.background = element_rect(fill = "grey90"),
    # plot.margin     = unit(c(0, 0, 0, 0), "cm") ,
    axis.line       = element_line(size = axis.line.size),
    axis.text       = element_text(size = axis.text.size),
    axis.ticks      = element_line(size = axis.line.size),
    axis.title      = element_text(size = axis.title.size*1.5),
    strip.background = element_blank(),
    strip.text = element_text(size = axis.title.size),
    legend.position = "none"
    )

ggsave(here("out", "indiv", "all_cors.pdf"), p.allcors, width = 17.6, height = 17.6/2, units = "cm")



w.super %>%
  
  filter(is.analysis.group) %>% 
  
  {
    
    grid.arrange(
      
        ggplot(., aes(dlpfc_R_target, lppc_R_target)) +
        stat_boot_ci(n = 1E4, alpha = 0.3, fill = colors.model["target"]) +
        geom_point(fill = colors.model["target"], color = "white", shape = 21, size = 4) +
        ggtitle("DLPFC~LPPC (right) target"),

      ggplot(., aes(dlpfc_R_incongruency, lppc_R_incongruency)) +
        stat_boot_ci(n = 1E4, alpha = 0.3, fill = colors.model["incongruency"]) +
        geom_point(fill = colors.model["incongruency"], color = "white", shape = 21, size = 4) +
        ggtitle("DLPFC~LPPC (right) incongruency"),
      
      ncol = 2
      
    )

  }


cors.lfp <- w.super %>%
  filter(is.analysis.group) %>% 
  summarize(
    r_target = cor(dlpfc_R_target, lppc_R_target), 
    r_incongruency = cor(dlpfc_R_incongruency, lppc_R_incongruency)
    ) %>%
  as.data.table


fwrite(cors.lfp, here("out", "indiv", "cors_lfp.txt"))

## combine

w.super$lfp_R_target <- (w.super$dlpfc_R_target + w.super$lppc_R_target) / 2
w.super$lfp_R_incongruency <- (w.super$dlpfc_R_incongruency + w.super$lppc_R_incongruency) / 2


```


## within-region interactions

```{r}

## create dataframe
stats.subjs.tdic %<>%
  group_by(scheme, is.analysis.group, id) %>%
  mutate(beta.s = scale(beta))

d.dissoc.hlm <- full_join(
  behav.mod.objs$fit1.het.trim$data, 
  w.super %>% ## scale betas
    filter(is.analysis.group) %>% ungroup %>% dplyr::select(subj, one_of(hyps)) %>% mutate_if(is.numeric, scale),
  by = "subj"
)

d.dissoc.hlm$lfp_R_target <- scale((d.dissoc.hlm$dlpfc_R_target + d.dissoc.hlm$lppc_R_target))
d.dissoc.hlm$lfp_R_incongruency <- scale((d.dissoc.hlm$dlpfc_R_incongruency + d.dissoc.hlm$lppc_R_incongruency))


## separate models ----

# first with hypothesized relationships:

mods <- list(
  dlpfc_L_targ  = update(behav.mod.objs$fit1.het.trim, rt ~ . + trial.type * dlpfc_L_target, data = d.dissoc.hlm),
  dlpfc_R_targ  = update(behav.mod.objs$fit1.het.trim, rt ~ . + trial.type * dlpfc_R_target, data = d.dissoc.hlm),
  lppc_L_targ   = update(behav.mod.objs$fit1.het.trim, rt ~ . + trial.type * lppc_L_target, data = d.dissoc.hlm),
  lppc_R_targ   = update(behav.mod.objs$fit1.het.trim, rt ~ . + trial.type * lppc_R_target, data = d.dissoc.hlm),
  dmfc_L_incon  = update(behav.mod.objs$fit1.het.trim, rt ~ . + trial.type * dmfc_L_incongruency, data = d.dissoc.hlm),
  dmfc_R_incon  = update(behav.mod.objs$fit1.het.trim, rt ~ . + trial.type * dmfc_R_incongruency, data = d.dissoc.hlm)
) 
sums <- lapply(mods, summary)
pvals <- lapply(sums, function(.) coef(.)[4, "p-value"])
pvals <- reshape2::melt(bind_rows(pvals), value.name = "p", variable = "id")
pvals$group  <- rep(1:3, each = 2)
pvals %<>% group_by(group) %>% mutate(p.fdr = p.adjust(p, method = "fdr"))

lapply(sums, coef)  ## print results
pvals  ## p values (corrected)


## now for within-region dissociations:

mods$dlpfc_R <- update(mods$dlpfc_R_targ, . ~ . + trial.type * dlpfc_R_incongruency)
mods$lppc_R <- update(mods$lppc_R_targ, . ~ . + trial.type * lppc_R_incongruency)
mods$dmfc_L <- update(mods$dmfc_L_incon, . ~ . + trial.type * dmfc_L_target)

W.single <- rbind("[Btarg(I-C)-Bincon(I-C)]" = c(0, 0, 0, 0, 1, -1))

summary(mods$dlpfc_R)
(contrast.dlpfc_R <- summary(glht(mods$dlpfc_R, W.single), test = adjusted("none")))  ## predicted: negative

summary(mods$lppc_R)
(contrast.lppc_R <- summary(glht(mods$lppc_R, W.single), test = adjusted("none")))  ## predicted: negative

summary(mods$dmfc_L)
(contrast.dmfc_L <- summary(glht(mods$dmfc_L, W.single), test = adjusted("none")))  ## predicted: positive


## finally, the 'full' model, to test for 4-way interaction:

mods$dmfc_L.lfp_R <- lme(
  
  rt ~ 
    trial.type * lfp_R_target +
    trial.type * lfp_R_incongruency +
    trial.type * dmfc_L_target +
    trial.type * dmfc_L_incongruency, 
  
  random  = ~ trial.type | subj,
  data    = d.dissoc.hlm,
  weights = varIdent(form = ~ 1 | subj),
  control = lmeControl(maxIter = 1e5, msMaxIter = 1e5, niterEM = 1e5, msMaxEval = 1e5),
  method  = "REML"
  
)

summary(mods$dmfc_L.lfp_R)

W.full <- rbind(
  "Btarg(I-C)-Bincon(I-C)|lfp"         = c(0, 0, 0, 0, 0, 0, 1, -1, 0, 0),  ## 3-way interaction within lfp
  "Btarg(I-C)-Bincon(I-C)|dmfc"        = c(0, 0, 0, 0, 0, 0, 0, 0, 1, -1),  ## 3-way interaction within dmfc
  "[Btarg(I-C)-Bincon(I-C)](lfp-dmfc)" = c(0, 0, 0, 0, 0, 0, 1, -1, -1, 1)  ## 4-way interaction
  )

(contrast.dmfc_L.lfp_R <- summary(glht(mods$dmfc_L.lfp_R, W.full), test = adjusted("none")))

## suppression?


## plot
# 
# ## refit model to get level-2 residuals sans mfc_L_target:
# 
# mods.lme$sans.mfc.targ <- update(mods.lme$mfc_L.lfp_R, . ~ . - trial.type * mfc_L_target)
# 
# resids <- data.frame(
#   
#   stroop = w.super %>% filter(is.analysis.group) %>% .$stroop,
#   
#   stroop.resid = ranef(mods.lme$sans.mfc.targ)[, 2],
#   
#   mfc_L_targ.resid = lm(
#     mfc_L_target ~ 
#       lfp_R_target + lfp_R_incongruency + mfc_L_incongruency, 
#     w.super %>% filter(is.analysis.group)
#     )$residuals,
#   
#   mfc_L_targ = w.super %>% filter(is.analysis.group) %>% .$mfc_L_target
#   
# )
# 
# cor(resids)
# 
# resids %>%
#   
#   ggplot(., aes(mfc_L_targ.resid, stroop.resid)) + 
#   stat_boot_ci(n = 1E4, alpha = 0.3, fill = colors.model["target"]) + 
#   geom_point(color = "white", shape = 21, size = 4, fill = colors.model["target"]) +
#   
#   labs(title = "partial correlation: stroop~MFC_L_target")

## get OLS estimates:

fits.bivar <- list(

  dmfc_L_target       = lm(stroop ~ dmfc_L_target, w.super %>% filter(is.analysis.group)),
  dmfc_L_incongruency = lm(stroop ~ dmfc_L_incongruency, w.super %>% filter(is.analysis.group)),
  lfp_R_target       = lm(stroop ~ lfp_R_target, w.super %>% filter(is.analysis.group)),
  lfp_R_incongruency = lm(stroop ~ lfp_R_incongruency, w.super %>% filter(is.analysis.group))

)
r2.bivar <- purrr::map(fits.bivar, summary) %>% purrr::map_dbl("r.squared")


fit <- lm(
  stroop ~ dmfc_L_target + lfp_R_target + lfp_R_incongruency + dmfc_L_incongruency,
  w.super %>% filter(is.analysis.group) %>% mutate_if(is.numeric, scale)
  )
summary(fit)
car::vif(fit)  ## not very collinear
kappa(fit)  ## relatively low...

r2.plus <-

  fits.bivar[-grep("dmfc_L_target", names(fits.bivar))] %>%

  purrr::map(function(x) update(x, . ~ . + dmfc_L_target)) %>%
  purrr::map(summary) %>%
  purrr::map_dbl("r.squared")

r2.delta <- r2.plus - r2.bivar[names(r2.plus)]

r2.delta.pev <- r2.delta / r2.bivar["dmfc_L_target"]  ## ~20-fold increase in variance explained....


## save results ----

indiv.mod.objs <- list(
  mods = mods, 
  sep.p = pvals, 
  contrasts.3way = list(
    dmfc_L = contrast.dmfc_L, 
    lppc_R = contrast.lppc_R,
    dlpfc_R = contrast.dlpfc_R
    ),
  contrasts.4way = contrast.dmfc_L.lfp_R
  )
saveRDS(indiv.mod.objs, here("out", "indiv", "indiv.RDS"))

# indiv.mod.objs.sep <- readRDS(here("out", "indiv", "indiv_separate.RDS"))
# mods <- indiv.mod.objs.sep$mods



```


# model selection analysis


```{r superparcels_elasticnet, cache = TRUE}

## estimate model ----

rm.these.cols <- grep("^congr$|^stroop$|\\.alt_", colnames(m.super))
X.super <- m.super[ids$is.analysis.group, -rm.these.cols]  ## analysis set

lambdas.super <- tune_lambda(X.super, strooprt, alpha = 0.5, selection_crit = function(fit) fit$lambda.1se)
hist(lambdas.super, breaks = 40, col = "grey50")
lambda.best.super <- min(Mode(lambdas.super))
table(lambdas.super)
net.super <- glmnet(x = X.super, y = strooprt, lambda = lambda.best.super, alpha = 0.5)
coef(net.super)


## estimate test error ----

X.super_p <- m.super[!ids$is.analysis.group, -rm.these.cols]  ## 'held out' / validation set

## observed error

ys.super <- cbind(
  y = c(strooprt_p),
  yhat = c(predict(net.super, newx = X.super_p))
  )

(cor.obs.super <- cor(ys.super)["y", "yhat"])

ys.super %>%
  as.data.frame %>%
  ggplot(aes(yhat, y)) +
  stat_boot_ci(n = 1e4, alpha = 0.3, color = "grey50") +
  geom_point()

## permuted validation error

cl <- makeCluster(n_cores - 1)
registerDoParallel(cl)
cor.perm.super <- foreach(ii = seq_len(nresamps), .inorder = FALSE, .combine = "c", .packages = "glmnet") %dorng% {

  yperm <- strooprt[sample.int(length(strooprt))]
  
  fit.ii <- glmnet(x = X.super, y = yperm, lambda = lambda.best.super, alpha = 0.5)

  cor(strooprt_p, predict(fit.ii, newx = X.super_p))

}
stopCluster(cl)

(p.super <- sum(cor.perm.super > cor.obs.super, na.rm = TRUE) / (nresamps - sum(is.na(cor.perm.super))))

plot(density(cor.perm.super, na.rm = TRUE))
abline(v = cor.obs.super, col = "firebrick", lwd = 3)

sum(is.na(cor.perm.super))  ## num models with no predictors


## variable importance
glmnet.elnet <- function(alpha = 0.5, ...) glmnet.lasso(..., alpha = alpha)
set.seed(0)
stabs.super <- stabsel(
  x = X.super, y = strooprt, q = 10, cutoff = 0.6, 
  fitfun = "glmnet.elnet"
  )
stabs.super
plot(stabs.super)

```


# MD MMP (Assem, 2020) parcel model selection and evaluation

* from set of 360 MMP parcels (180/hemisphere), 11 parcels (per hemisphere) were independently defined as commonly involved in multiple different cognitive tasks within HCP dataset (Assem, 2019)
  * strong correspondence to "multiple demand" network discussed in previous research (e.g., Duncan, Fedorenko, and colleagues).
* 11 parcels * 2 hemispheres * 3 RSA models = 66 features
* same elastic net selection and evaluation procedure as above
    * however, lambda chosen that minimizes CV test error (not min+1SE)
    * in lambda = min+1se, no variables were selected

```{r md_elasticnet, cache = TRUE}

names.md <- colnames(w.mmp)[grep(paste0(md$core, collapse = "|"), colnames(w.mmp))]

## estimate model ----

X.md <- m.mmp[ids$is.analysis.group, names.md]

## find lambda and fit

lambdas.md <- tune_lambda(X.md, strooprt, alpha = 0.5, selection_crit = function(fit) fit$lambda.min)
hist(lambdas.md, breaks = 50, col = "grey50")
lambda.best.md <- min(Mode(lambdas.md))

net.md <- glmnet(x = X.md, y = strooprt, lambda = lambda.best.md, alpha = 0.5)
coef(net.md)

## estimate test error ----

X.md_p <- m.mmp[!ids$is.analysis.group, names.md]  ## 'held out' / validation set

## observed error

ys.md <- cbind(
  y = c(strooprt_p),
  yhat = c(predict(net.md, newx = X.md_p))
  )

(cor.obs.md <- cor(ys.md)["y", "yhat"])

ys.md %>%
  as.data.frame %>%
  ggplot(aes(yhat, y)) +
  stat_boot_ci(n = 1e4, alpha = 0.3, color = "grey50") +
  geom_point()

## permuted validation error

cl <- makeCluster(n_cores - 1)
registerDoParallel(cl)
cor.perm.md <- foreach(ii = seq_len(nresamps), .inorder = FALSE, .combine = "c", .packages = "glmnet") %dorng% {

  yperm <- strooprt[sample.int(length(strooprt))]
  
  fit.ii <- glmnet(x = X.md, y = yperm, lambda = lambda.best.md, alpha = 0.5)

  cor(strooprt_p, predict(fit.ii, newx = X.md_p))

}
stopCluster(cl)

(p.md <- sum(cor.perm.md > cor.obs.md, na.rm = TRUE) / (nresamps - sum(is.na(cor.perm.md))))

plot(density(cor.perm.md))
abline(v = cor.obs.md, col = "firebrick", lwd = 3)

sum(is.na(cor.perm.md))

## variable importance

stabs.md <- stabsel(
  x = X.md, y = strooprt, q = 10, cutoff = 0.6, 
  fitfun = "glmnet.elnet",
  )
stabs.md
plot(stabs.md)

```

