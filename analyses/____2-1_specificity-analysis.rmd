---
  title: "specificity analysis"
  output: html_document
---

Conducts RSA model comparisons and defines different "types" of representational profiles (e.g., "target selective".)
Writes workbench files for the conjunction map.

```{r setup}

## about ----

## set up env. ----

write.wb <- FALSE

library(here)
library(magrittr)
library(dplyr)
library(data.table)
library(ggplot2)
source(here("..", "gen", "funs", "_get_dirs_local.R"))
source(here("..", "gen", "funs", "_funs.R"))
source(here("r", "group-201902", "_get_misc_vars.R"))
source(here("r", "group-201902", "_read_files_local.R"))

## for printing results:
mmp <- atlas.key$mmp
mmp <- bind_rows(
  mmp %>% mutate(parcel.hemi = paste0(roi, "_l")),
  mmp %>% mutate(parcel.hemi = paste0(roi, "_r"))
)
mmp %<>% select(parcel.hemi, community) %>% arrange(community, parcel.hemi)

```


# run pairwise tests

Wilcoxon sign-rank test, two-sided, p-values FDR corrected among multiple comparisons within parcel (i.e., among 3 comparisons).


```{r pairwise-comps, warning = FALSE}

paircomps <- coefs %>%
  select(subj, parcel, hemi, variable, rho) %>%
  tidyr::spread(variable, rho) %>%
  melt %>%
  group_by(parcel, hemi) %>%
  summarize(
    pairwise = list(
      pairwise.wilcox.test(value, variable, paired = TRUE, alternative = "two.sided", p.adjust.method = "fdr")
    )
  )  ## warnings indicate non-exact p-values
pvals <- sapply(paircomps$pairwise, function(.) .$p.value[lower.tri(diag(2), diag = TRUE)])
pvals <- t(pvals)
# paircomps$pairwise[[1]]$p.value
# paircomps$pairwise[[1]]$p.value[lower.tri(diag(2), diag = TRUE)]
colnames(pvals) <- c("cong.dist", "targ.cong", "targ.dist")
paircomps <- cbind(as.data.frame(paircomps[c("parcel", "hemi")]), as.data.frame(pvals))
paircomps$parcel.hemi <- paste0(paircomps$parcel, "_", paircomps$hemi)

write.csv(
  paircomps,
  file.path(
    dir.box.stroop.stats, 
    "parcel-pairwise_pcor_rsm-pearson_mmp_group-201902_pro_bias_acc-only_residual.csv"
    ),
  row.names = FALSE
  )

## get pairwise incongruency stats

pairwise.i <- read.csv(
  file.path(
    dir.box.stroop.stats, 
    "parcel-coefs_pairwise-incon_pcor_rsm-pearson_mmp_group-201902_pro_bias_acc-only_residual.csv"
    )
  )

results.i <- read.csv(
  file.path(
    dir.box.stroop.stats, 
    "parcel-coefs_pcor_rsm-pearson_mmp_group-201902_pro_bias_acc-only_residual_congruency-schemes.csv"
    )
  ) %>%
  filter(variable == "incongruency") %>%
  dplyr::full_join(atlas.key$mmp %>% dplyr::rename(parcel = "roi"), by = "parcel")  %>%  ## need ROI numbers
  dplyr::mutate(parcel.hemi = paste0(parcel, "_", hemi)) %>%
  ## create p.adjusted col:
  dplyr::group_by(variable) %>%
  dplyr::mutate(
    p.adj.wb = p.adjust(rho.srtest.p, method = "fdr"),
  )
  #   is.roi   = parcel.hemi %in% rois.mmp$roi.hemi[rois.mmp$dmcc2.taskgen > 1]  ## dmcc2.taskgen == 2 -> most conserv.
  # ) %>%
  # dplyr::group_by(variable, is.roi) %>%
  # dplyr::mutate(
  #   p.adj.roi = p.adjust(rho.srtest.p, method = "fdr"),
  #   p.adj.roi = ifelse(is.roi, p.adj.roi, p.adj.wb)
  # )
  
```


# results


## 'CODING' PARCELS

Parcels with a task-dimension representation greater than 0 with $p < 0.05$.

```{r coding-parcels}
 
# parcels.targ <- results %>% filter(variable == "target", p.adj.roi < 0.05) %>% .$parcel.hemi %>% unique
# parcels.cong <- results %>% filter(variable == "congruency", p.adj.roi < 0.05) %>% .$parcel.hemi %>% unique
# parcels.dist <- results %>% filter(variable == "distractor", p.adj.roi < 0.05) %>% .$parcel.hemi %>% unique
# parcels.incong <- results.i %>% filter(variable == "incongruency", p.adj.roi < 0.05) %>% .$parcel.hemi %>% unique


parcels.targ <- results %>% filter(variable == "target", p.adj.wb < 0.05) %>% .$parcel.hemi %>% unique
parcels.cong <- results %>% filter(variable == "congruency", p.adj.wb < 0.05) %>% .$parcel.hemi %>% unique
parcels.dist <- results %>% filter(variable == "distractor", p.adj.wb < 0.05) %>% .$parcel.hemi %>% unique
parcels.incong <- results.i %>% filter(variable == "incongruency", p.adj.wb < 0.05) %>% .$parcel.hemi %>% unique


```

### target coding parcels

```{r coding-parcels-targ}

mmp[mmp$parcel.hemi %in% parcels.targ, ]

```

### distractor coding parcels

```{r coding-parcels-dist}

mmp[mmp$parcel.hemi %in% parcels.dist, ]

```

### congruency coding parcels

```{r coding-parcels-cong}

mmp[mmp$parcel.hemi %in% parcels.cong, ]

```


### incongruency coding parcels

```{r coding-parcels-incong}

mmp[mmp$parcel.hemi %in% parcels.incong, ]

setdiff(parcels.incong, parcels.cong)
setdiff(parcels.cong, parcels.incong)

```


## 'UNI-CODING' PARCELS

Parcels with ONLY 1 task dimension representation greater than 0.

### target-only coding parcels

```{r, parcels-targ-only}

parcels.targ.only <- setdiff(parcels.targ, c(parcels.cong, parcels.dist))  ## (a)

mmp[mmp$parcel.hemi %in% parcels.targ.only, ]

```

### distractor-only coding parcels

```{r, parcels-dist-only}

parcels.dist.only <- setdiff(parcels.dist, c(parcels.cong, parcels.targ))

mmp[mmp$parcel.hemi %in% parcels.dist.only, ]

```


### congruency-only coding parcels

```{r, parcels-cong-only}

parcels.cong.only <- setdiff(parcels.cong, c(parcels.targ, parcels.dist))

mmp[mmp$parcel.hemi %in% parcels.cong.only, ]

```


## 'SELECTIVE' PARCELS

Parcels with with ONLY 1 task dimension representation greater than 0 (i.e., 'uni-coding' parcels), AND greater than other representations (with $p < 0.05$).

### target selective parcels

For example, if $\mathbf{t}_1$ is target coding in parcel 1, parcel 1 would appear here if $\mathbf{t}_1 > 0$,  $\mathbf{t}_1 > \mathbf{d}_1$, AND $\mathbf{t}_1 > \mathbf{c}_1$ (with $p < 0.05$).


```{r, parcels-targ-selective}

parcels.targ.selective <- paircomps %>%
  filter(parcel.hemi %in% parcels.targ.only, targ.cong < 0.05, targ.dist < 0.05) %>%
  .$parcel.hemi

mmp[mmp$parcel.hemi %in% parcels.targ.selective, ]

```

### distractor-selective parcels

```{r, parcels-dist-selective}

parcels.dist.selective <- paircomps %>%
  filter(parcel.hemi %in% parcels.dist.only, targ.dist < 0.05, cong.dist < 0.05) %>%
  .$parcel.hemi

mmp[mmp$parcel.hemi %in% parcels.dist.selective, ]

```

### congruency-selective parcels

```{r, parcels-cong-selective}

parcels.cong.selective <- paircomps %>%
  filter(parcel.hemi %in% parcels.cong.only, targ.cong < 0.05, cong.dist < 0.05) %>%
  .$parcel.hemi

mmp[mmp$parcel.hemi %in% parcels.cong.selective, ]

```


## 'MULTI-CODING' PARCELS

Parcels with MORE THAN ONE task dimension representation greater than 0.

## target--congruency coding parcels

```{r, parcels-targ-cong}

parcels.targ.cong.only <- setdiff(intersect(parcels.targ, parcels.cong), parcels.dist)

mmp[mmp$parcel.hemi %in% parcels.targ.cong.only, ]

```

## target--distractor coding parcels

```{r, parcels-targ-dist}

parcels.targ.dist.only <- setdiff(intersect(parcels.targ, parcels.dist), parcels.cong)

mmp[mmp$parcel.hemi %in% parcels.targ.dist.only, ]

```

## distractor--congruency coding parcels

```{r, parcels-dist-cong}

parcels.dist.cong.only <- setdiff(intersect(parcels.dist, parcels.cong), parcels.targ)

mmp[mmp$parcel.hemi %in% parcels.dist.cong.only, ]

```

## parcels coding all 3 dims

```{r, parcels-targ-dist-cong}

parcels.all3 <- intersect(intersect(parcels.dist, parcels.cong), parcels.targ)

mmp[mmp$parcel.hemi %in% parcels.all3, ]

```

## target--incongruency coding parcels

```{r, parcels-targ-incong}

parcels.targ.incong.only <- setdiff(intersect(parcels.targ, parcels.incong), parcels.dist)

mmp[mmp$parcel.hemi %in% parcels.targ.incong.only, ]

```


## 'MULTI-SELECTIVE' PARCELS

### target--congruency selective

Parcels where $\mathbf{t}_{parcel} > 0$, $\mathbf{c}_{parcel} > 0$ AND $\mathbf{t}_{parcel} > \mathbf{d}_{parcel}$, $\mathbf{c}_{parcel} > \mathbf{d}_{parcel}$.

```{r, parcels-targ-cong-selective}

parcels.targ.cong.selective <- paircomps %>%
  filter(parcel.hemi %in% parcels.targ.cong.only, targ.dist < 0.05, cong.dist < 0.05) %>%
  .$parcel.hemi

mmp[mmp$parcel.hemi %in% parcels.targ.cong.selective, ]

```


### target--incongruency selective

Parcels where $\mathbf{t}_{parcel} > 0$, $\mathbf{i}_{parcel} > 0$ AND $\mathbf{t}_{parcel} > \mathbf{d}_{parcel}$, $\mathbf{i}_{parcel} > \mathbf{d}_{parcel}$.

```{r, parcels-targ-incong-selective}

parcels.targ.incong.selective <- paircomps %>%
  filter(parcel.hemi %in% parcels.targ.incong.only, targ.dist < 0.05, cong.dist < 0.05) %>%
  .$parcel.hemi

mmp[mmp$parcel.hemi %in% parcels.targ.incong.selective, ]

```


### target--distractor selective

Parcels where $\mathbf{t}_{parcel} > 0$, $\mathbf{d}_{parcel} > 0$ AND $\mathbf{t}_{parcel} > \mathbf{c}_{parcel}$, $\mathbf{d}_{parcel} > \mathbf{c}_{parcel}$.

```{r, parcels-targ-dist-selective}

parcels.targ.dist.selective <- paircomps %>%
  filter(parcel.hemi %in% parcels.targ.dist.only, targ.cong < 0.05) %>%
  .$parcel.hemi

mmp[mmp$parcel.hemi %in% parcels.targ.dist.selective, ]

```

## 'TASK-RELEVANT' PARCELS

Parcels where $\mathbf{t}_{parcel} > 0$ AND $\mathbf{t}_{parcel} > \mathbf{d}_{parcel}$.
No constraints on $\mathbf{c}_{parcel}$.

```{r, parcels-task-rel}

parcels.task.relevant <- paircomps %>%
  filter(parcel.hemi %in% parcels.targ, targ.dist < 0.05) %>%
  .$parcel.hemi

mmp[mmp$parcel.hemi %in% parcels.task.relevant, ]

parcels.task.relevant[parcels.task.relevant %in% parcels.cong]  ## task-rel parcels with c > 0

## targ coding parcels that did not meet the t > d criterion:
mmp[mmp$parcel.hemi %in% setdiff(parcels.targ, parcels.task.relevant), ]


```

# write workbench files

```{r, write-to-wb, eval = write.wb}

## selective parcels:
## target selective
## congruency selective
## target--congruency selective

## task-relevant parcels
## target only
## + congruency
## - not above distractor

df <- results %>%
  group_by(parcel, hemi, parcel.hemi, num.roi) %>%
  summarize %>%
  mutate(
    selective = ifelse(
      parcel.hemi %in% parcels.targ.selective,
      "targ", 
      ifelse(
        parcel.hemi %in% parcels.cong.selective,
        "cong", 
        ifelse(parcel.hemi %in% parcels.targ.cong.selective, "targ.cong", NA)
      )
    ),
    task.rel = ifelse(
      parcel.hemi %in% setdiff(parcels.task.relevant, parcels.cong),
      "task.rel",
      ifelse(
        parcel.hemi %in% intersect(parcels.task.relevant, parcels.cong),
        "task.rel.cong",
        ifelse(
          parcel.hemi %in% setdiff(parcels.targ, parcels.task.relevant),
          "targ", NA
        )
      )
    )
  )

df$selective <- as.numeric(factor(df$selective, levels = c("targ", "cong", "targ.cong")))
df$task.rel  <- as.numeric(factor(df$task.rel, levels = c("task.rel", "task.rel.cong", "targ")))
df$selective[is.na(df$selective)] <- 0
df$task.rel[is.na(df$task.rel)] <- 0

write.pscalar(
  dir.to.write   = file.path(dir.masters, "wb"),
  fname.overlay  = "selective",
  values.overlay = arrange(df, desc(hemi), num.roi)$selective
  )

write.pscalar(
  dir.to.write   = file.path(dir.masters, "wb"),
  fname.overlay  = "taskrel",
  values.overlay = arrange(df, desc(hemi), num.roi)$task.rel
  )


## conjunction (for conjunction-and-mds figure) ----


df %<>%
  mutate(
    conjunction = ifelse(
      parcel.hemi %in% setdiff(parcels.task.relevant, parcels.cong),
      1.15, #"task.rel",
      ifelse(
        parcel.hemi %in% parcels.cong.selective,
        5, #"cong.selective",
        ifelse(
          parcel.hemi %in% parcels.targ.cong.selective,
          3, #"targ.cong.selective",
          ifelse(
            parcel.hemi %in% parcels.dist.only,
            4.6, #"dist",
            ifelse(
              parcel.hemi %in% parcels.targ.dist.only,
              3.9, #"targ.dist",
              0 #NA
            )
          )
        )
      )
    )
  )

# df$conjunction <- as.numeric(as.factor(df$conjunction))
# df$conjunction[is.na(df$conjunction)] <- 0

write.pscalar(
  dir.to.write   = file.path(dir.masters, "wb"),
  fname.overlay  = "conjunction",
  values.overlay = arrange(df, desc(hemi), num.roi)$conjunction
  )

```

