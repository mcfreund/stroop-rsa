---
  title: "invariance analysis"
  output: html_document
---
  
Assesses robustness of RSA model fits to particular choice of procedures.

* Model structure (glms)
  * tdi vs tdci
* Model fit method
  * rank betas versus linear betas (spearman's versus pearson's) | categorical models
  * rank betas versus linear coefficients (spearman's versus mean contrast) | categorical models
  * rank betas versus tau-a | all models


```{r setup}

library(here)
library(magrittr)
library(dplyr)
library(data.table)
library(ggplot2)
library(mikeutils)
source(here("code", "_strings.R"))
source(here("code", "_funs.R"))
source(here("code", "_get_atlas.R"))

stats.subjs <- rbind(
  fread(here("out", "rsa", "stats", paste0("subjs_pro_bias_acc-only_mmp_pearson_residual_glm-tdic.csv"))),
  fread(here("out", "rsa", "stats", paste0("subjs_pro_bias_acc-only_mmp_pearson_residual_glm-tdi.csv"))),
  fread(here("out", "rsa", "stats", paste0("subjs_pro_bias_acc-only_mmp_pearson_residual_glm-tdclust.csv")))
  )
stats.subjs <- stats.subjs[is.analysis.group == TRUE]  ## EXCLUDE HELD OUT SUBJECTS!

stats.subjs.taua <- fread(
  here("out", "rsa", "stats", paste0("subjs_pro_bias_acc-only_mmp_pearson_residual_taua.csv"))
  )[is.analysis.group == TRUE]  ## EXCLUDE HELD OUT SUBJECTS!

```


# model structure: __tdi__ versus __tdic__ (rank betas)

The __tdi__ model 
\[
  \textbf{y} \sim 
  \textbf{x}_{\text{targt}}\beta_{\text{targt}} + 
  \textbf{x}_{\text{distr}}\beta_{\text{distr}} + 
  \textbf{x}_{\text{incon}}\beta_{\text{incon}}
\]
and the __tdci__ model
\[
  \textbf{y} \sim 
  \textbf{x}_{\text{targt}}\beta_{\text{targt}} + 
  \textbf{x}_{\text{distr}}\beta_{\text{distr}} + 
  \textbf{x}_{\text{incon}}\beta_{\text{incon}} +
  \textbf{x}_{\text{congr}}\beta_{\text{congr}}
\]
differ in the inclusion of the congruency regressor ($\textbf{x}_{\text{congr}}$).
The congruency regressor is an indicator for correlations between congruent items.
Thus, the intercept ('baseline') of these models differs in whether congruent items are included (in __tdi__) or excluded (__tdic__).

The coefficients (betas) of interest from these models ($\beta_{\text{targt}}$, $\beta_{\text{distr}}$, $\beta_{\text{incon}}$) reflect the (semi-partial spearman) correlation with the regressor, relative to the intercept.
These alternative parameterizations may therefore give differing results.

## stats

```{r tdi-vs-tdic_est}

d <- stats.subjs[model %in% c("tdi", "tdic") & param == "incongruency" & y == "rank"]

tdi.vs.tdic <- d %>%
  group_by(model, param, roi.hemi) %>%
  summarize(
    v    = wilcox.test(beta, alternative = "greater")$statistic,
    p    = wilcox.test(beta, alternative = "greater")$p.value,
    beta = tanh(mean(atanh(beta))),  ## must be last in this summarize()
  ) %>%
  group_by(model, param) %>%
  mutate(p.fdr = p.adjust(p, method = "fdr"), p.holm = p.adjust(p, method = "holm"))

```

## results

ROIs identified by both __tdi__ and __tdic__.

```{r tdi-vs-tdic_results_intersect}

intersect(
  filter(tdi.vs.tdic, p.fdr < 0.05, model == "tdic")$roi.hemi,
  filter(tdi.vs.tdic, p.fdr < 0.05, model == "tdi")$roi.hemi
)

```

ROIs in __tdi__ but not in __tdic__.
(i.e., should be ROIs in which congruent patterns tended to be dissimilar).

```{r tdi-vs-tdic_results_not-in-tdic}

setdiff(
  filter(tdi.vs.tdic, p.fdr < 0.05, model == "tdi")$roi.hemi,
  filter(tdi.vs.tdic, p.fdr < 0.05, model == "tdic")$roi.hemi
)

```

ROIs in tdic but not in tdi.
(should be ROIs in which congruent patterns tended to be similar).

```{r tdi-vs-tdic_results-not-in-tdi}

setdiff(
  filter(tdi.vs.tdic, p.fdr < 0.05, model == "tdic")$roi.hemi,
  filter(tdi.vs.tdic, p.fdr < 0.05, model == "tdi")$roi.hemi
)

```

ROIs where tdic and tdi incongruency betas are significantly different.

```{r tdi-vs-tdic_results-comparison}

tdi.vs.tdic.wide <- d %>%
  select(subj, roi.hemi, model, beta) %>%
  group_by(model, roi.hemi) %>%
  tidyr::spread(model, beta)

tdi.vs.tdic.wide %>%  
  filter(roi.hemi %in% tdi.vs.tdic$roi.hemi[tdi.vs.tdic$p.fdr < 0.05]) %>%
  summarize(
    v    = wilcox.test(tdic, tdi, paired = TRUE)$statistic,
    p    = wilcox.test(tdic, tdi, paired = TRUE)$p.value,
    beta = tanh(mean(atanh(tdic) - atanh(tdi))),  ## must be last in this summarize()
  ) %>%
  mutate(p.fdr = p.adjust(p, method = "fdr"), p.holm = p.adjust(p, method = "holm")) %>%
  filter(p.fdr < 0.05)  ## no ROIs

## plot

plot.new()

par(mfrow = c(1, 2))

tdi.vs.tdic.wide %>%
  group_by(subj) %>%
  summarize_if(is.numeric, function(x) tanh(mean(atanh(x)))) %>%
  select(tdi, tdic) %>%
  plot
abline(0, 1)
title("by subject")

tdi.vs.tdic.wide %>%
  group_by(roi.hemi) %>%
  summarize_if(is.numeric, function(x) tanh(mean(atanh(x)))) %>%
  select(tdi, tdic) %>%
  plot
abline(0, 1)
title("by ROI")

mtext("association between incongruency estimates from tdic versus tdi models", side = 3, line = -1, outer = TRUE)

## correlations:

tdi.vs.tdic.wide %>%
  group_by(roi.hemi) %>%
  summarize_if(is.numeric, function(x) tanh(mean(atanh(x)))) %>%
  select(tdi, tdic) %>%
  cor

tdi.vs.tdic.wide %>%
  group_by(subj) %>%
  summarize_if(is.numeric, function(x) tanh(mean(atanh(x)))) %>%
  select(tdi, tdic) %>%
  cor

```


## conclusion

No notable differences between __tdic__ and __tdi__ models.
Use __tdic__ as main categorical model structure as it estimates additional information (congruency), and has a more intuitive baseline (intercept). (But report both).


# model fit method: betas from rank regression versus from linear regression

Regression models were either fit on repsonse variables that were rank transformed, or on the raw values.
The vector __r__ is composed of each unique element of the observed representational simialrity matrix (for a give ROI and subject).

The rank model is then specified by
\[
  rank(\textbf{r}) \sim 
  \textbf{x}_{\text{targt}}\beta_{\text{targt}} + 
  \textbf{x}_{\text{distr}}\beta_{\text{distr}} + 
  \textbf{x}_{\text{incon}}\beta_{\text{incon}} +
  \textbf{x}_{\text{congr}}\beta_{\text{congr}}
\]
where $rank$ indicates the rank transform.
Similarly, the linear model is specified by
\[
  atanh(\textbf{r}) \sim 
  \textbf{x}_{\text{targt}}\beta_{\text{targt}} + 
  \textbf{x}_{\text{distr}}\beta_{\text{distr}} + 
  \textbf{x}_{\text{incon}}\beta_{\text{incon}} +
  \textbf{x}_{\text{congr}}\beta_{\text{congr}}
\]
where $atanh$ indicates the Fisher's z-transform.

The rank-transformed regression betas are eqivalent to a semi-partial spearman's correlation between model RSM and observed.
The linear regression betas are eqivalent to a semi-partial pearson's correlation.

Here I assess whether these transformations may lead to different interpretation of the results.


```{r rank-vs-line_est}

d.tdic <- stats.subjs[model == "tdic"]

stats.group.tdic <- d.tdic %>%
  group_by(param, y, roi.hemi) %>%
  summarize(
    v    = wilcox.test(beta, alternative = "greater")$statistic,
    p    = wilcox.test(beta, alternative = "greater")$p.value,
    beta = tanh(mean(atanh(beta))),  ## must be last in this summarize()
  ) %>%
  group_by(param, y) %>%
  mutate(p.fdr = p.adjust(p, method = "fdr"), p.holm = p.adjust(p, method = "holm"))

```

## results

ROIs identified by both __rank__ and __linear__.

```{r rank-vs-line_results_intersect}

params <- c("target", "distractor", "incongruency")

rank.vs.line.intersect <- lapply(
  params, function(x) {
    intersect(
      filter(stats.group.tdic, p.fdr < 0.05, param == x, y == "rank")$roi.hemi,
      filter(stats.group.tdic, p.fdr < 0.05, param == x, y == "z")$roi.hemi
      )
  }
)
rank.vs.line.intersect <- setNames(rank.vs.line.intersect, params)

rank.vs.line.intersect

```

ROIs in __rank__ but not in __linear__.

```{r rank-vs-line_results_not-in-linear}

rank.vs.line.notinlinear <- lapply(
  params, function(x) {
    setdiff(
      filter(stats.group.tdic, p.fdr < 0.05, param == x, y == "rank")$roi.hemi,
      filter(stats.group.tdic, p.fdr < 0.05, param == x, y == "z")$roi.hemi
      )
  }
)
rank.vs.line.notinlinear <- setNames(rank.vs.line.notinlinear, params)

rank.vs.line.notinlinear

```

ROIs in __linear__ but not in __rank__.

```{r rank-vs-line_results_not-in-rank}

rank.vs.line.notinrank <- lapply(
  params, function(x) {
    setdiff(
      filter(stats.group.tdic, p.fdr < 0.05, param == x, y == "z")$roi.hemi,
      filter(stats.group.tdic, p.fdr < 0.05, param == x, y == "rank")$roi.hemi
      )
  }
)
rank.vs.line.notinrank <- setNames(rank.vs.line.notinrank, params)

rank.vs.line.notinrank

```

ROIs where __rank__ and __linear__ model betas are significantly different.

```{r rank-vs-line_results_comparison}

rank.vs.line.wide <- d.tdic %>%
  filter(param %in% params) %>%
  select(subj, roi.hemi, param, y, beta) %>%
  group_by(param, y, roi.hemi) %>%
  tidyr::spread(y, beta)

rank.vs.line.diff <- rank.vs.line.wide %>%  
  group_by(roi.hemi, param) %>%
  summarize(
    v    = wilcox.test(z, rank, paired = TRUE)$statistic,
    p    = wilcox.test(z, rank, paired = TRUE)$p.value,
    beta = tanh(mean(atanh(z) - atanh(rank))),  ## must be last in this summarize()
  ) %>%
  filter(p < 0.05)

## target

rank.vs.line.diff %>% 
  filter(
    param == "target", roi.hemi %in% c(
      ## union of sets:
      rank.vs.line.intersect$target, 
      rank.vs.line.notinlinear$target, 
      rank.vs.line.notinrank$target
      )
    ) %>%
  arrange(beta)

## distractor

rank.vs.line.diff %>% 
  filter(
    param == "distractor", roi.hemi %in% c(
      ## union of sets:
      rank.vs.line.intersect$distractor, 
      rank.vs.line.notinlinear$distractor, 
      rank.vs.line.notinrank$distractor
      )
    ) %>%
  arrange(beta)

## incongruency

rank.vs.line.diff %>% 
  filter(
    param == "incongruency", roi.hemi %in% c(
      ## union of sets:
      rank.vs.line.intersect$incongruency, 
      rank.vs.line.notinlinear$incongruency, 
      rank.vs.line.notinrank$incongruency
      )
    ) %>%
  arrange(beta)

## plot

plot.new()

par(mfrow = c(1, 2))

rank.vs.line.wide %>%
  group_by(subj) %>%
  summarize_if(is.numeric, function(x) tanh(mean(atanh(x)))) %>%
  select(z, rank) %>%
  plot
abline(0, 1)
title("by subject")

rank.vs.line.wide %>%
  group_by(roi.hemi) %>%
  summarize_if(is.numeric, function(x) tanh(mean(atanh(x)))) %>%
  select(z, rank) %>%
  plot
abline(0, 1)
title("by ROI")

mtext("association between incongruency estimates from rank versus linear models", side = 3, line = -1, outer = TRUE)

## correlations:

rank.vs.line.wide %>%
  group_by(subj) %>%
  summarize_if(is.numeric, function(x) tanh(mean(atanh(x)))) %>%
  select(z, rank) %>%
  cor

rank.vs.line.wide %>%
  group_by(roi.hemi) %>%
  summarize_if(is.numeric, function(x) tanh(mean(atanh(x)))) %>%
  select(z, rank) %>%
  cor

```

## conclusions

There seems to be some loss of sensitivity in using a rank-transformed response variable.
Specifically, the linear model identifies a handful of target and incongruency coding ROIs that the rank model did not.
(Most of these ROIs are coding for target.)
Some of these ROIs have significantly greater betas from linear versus rank, but again most of these are for the target regressor.
Further the effect sizes of the difference are quite small.

This loss of sensitivity is expected with rank procedures. But because it is the default for RSA model fitting, and it does not seem to be massively obscuring many positive results, it is preferrable.


# model fit method: betas from rank regression versus bivariate correlations from kendall's $\tau_A$

## stats

#### __task coding analysis__: test each regressor against zero (baseline)

```{r rank-vs-taua_est}

d.tdic.rank <- d.tdic[y == "rank"]

stats.group.taua <- stats.subjs.taua %>%
  filter(param %in% params) %>%
  group_by(param, roi.hemi) %>%
  summarize(
    v    = wilcox.test(taua, alternative = "greater")$statistic,
    p    = wilcox.test(taua, alternative = "greater")$p.value,
    taua = tanh(mean(atanh(taua))),  ## must be last in this summarize()
  ) %>%
  group_by(param) %>%
  mutate(p.fdr = p.adjust(p, method = "fdr"), p.holm = p.adjust(p, method = "holm"))

```

#### __preference analysis__: pairwise comparisons

```{r preference_tdic}

stats.pairs.tdic <- d.tdic.rank %>%
  filter(param %in% params) %>%
  group_by(roi.hemi) %>%
  summarize(
    out = list(
      pairwise.wilcox.test(beta, param, paired = TRUE, alternative = "two.sided", p.adjust.method = "fdr")
    )
  )
pvals <- vapply(stats.pairs.tdic$out, function(.) .$p.value[lower.tri(diag(2), diag = TRUE)], numeric(3))
pvals <- t(pvals)
colnames(pvals) <- c("p.incon.distr", "p.targt.distr", "p.targt.incon")
stats.pairs.tdic <- as.data.frame(cbind(roi.hemi = stats.pairs.tdic$roi.hemi, pvals), stringsAsFactors = FALSE)

## get mean diffs

stats.pairs.tdic %<>% full_join(
  d.tdic.rank %>%
    filter(param %in% params) %>%
    group_by(roi.hemi) %>%
    summarize(
      b.incon.distr = tanh(mean(atanh(beta[param == "incongruency"]) - atanh(beta[param == "distractor"]))),
      b.targt.distr = tanh(mean(atanh(beta[param == "target"]) - atanh(beta[param == "distractor"]))),
      b.targt.incon = tanh(mean(atanh(beta[param == "target"]) - atanh(beta[param == "incongruency"]))),
    ),
  by = "roi.hemi"
)

# stats.pairs.tdic %<>% full_join(mmp, by = "roi.hemi") %>% as.data.table

```


```{r preference_taua}

stats.pairs.taua <- stats.subjs.taua %>%
  filter(param %in% params) %>%
  group_by(roi.hemi) %>%
  summarize(
    out = list(
      pairwise.wilcox.test(taua, param, paired = TRUE, alternative = "two.sided", p.adjust.method = "fdr")
    )
  )
pvals <- vapply(stats.pairs.taua$out, function(.) .$p.value[lower.tri(diag(2), diag = TRUE)], numeric(3))
pvals <- t(pvals)
colnames(pvals) <- c("p.incon.distr", "p.targt.distr", "p.targt.incon")
stats.pairs.taua <- as.data.frame(cbind(roi.hemi = stats.pairs.taua$roi.hemi, pvals), stringsAsFactors = FALSE)

## get mean diffs

stats.pairs.taua %<>% full_join(
  stats.subjs.taua %>%
    filter(param %in% params) %>%
    group_by(roi.hemi) %>%
    summarize(
      b.incon.distr = tanh(mean(atanh(taua[param == "incongruency"]) - atanh(taua[param == "distractor"]))),
      b.targt.distr = tanh(mean(atanh(taua[param == "target"]) - atanh(taua[param == "distractor"]))),
      b.targt.incon = tanh(mean(atanh(taua[param == "target"]) - atanh(taua[param == "incongruency"]))),
    ),
  by = "roi.hemi"
)

# stats.pairs.tdic %<>% full_join(mmp, by = "roi.hemi") %>% as.data.table

```


## results

#### __task coding analysis__: test each regressor against zero (baseline)

ROIs identified by both __rank__ and __$\tau_A$__.

```{r rank-vs-taua_results_intersect}

rank.vs.taua.intersect <- lapply(
  params, function(x) {
    intersect(
      filter(stats.group.tdic, p.fdr < 0.05, param == x, y == "rank")$roi.hemi,
      filter(stats.group.tdic, p.fdr < 0.05, param == x)$roi.hemi
      )
  }
)
rank.vs.taua.intersect <- setNames(rank.vs.taua.intersect, params)

rank.vs.taua.intersect

```

ROIs in __rank__ but not in __$\tau_A$__.

```{r rank-vs-taua_results_not-in-linear}

rank.vs.taua.notintaua <- lapply(
  params, function(x) {
    setdiff(
      filter(stats.group.tdic, p.fdr < 0.05, param == x, y == "rank")$roi.hemi,
      filter(stats.group.tdic, p.fdr < 0.05, param == x)$roi.hemi
      )
  }
)
rank.vs.taua.notintaua <- setNames(rank.vs.taua.notintaua, params)

rank.vs.taua.notintaua

```

ROIs in __$\tau_A$__ but not in __rank__.

```{r rank-vs-taua_results_not-in-rank}

rank.vs.taua.notinrank <- lapply(
  params, function(x) {
    setdiff(
      filter(stats.group.tdic, p.fdr < 0.05, param == x)$roi.hemi,
      filter(stats.group.tdic, p.fdr < 0.05, param == x, y == "rank")$roi.hemi
      )
  }
)
rank.vs.taua.notinrank <- setNames(rank.vs.taua.notinrank, params)

rank.vs.taua.notinrank

```

##### Direct comparison.

ROIs where __rank__ and __$\tau_A$__ model betas are significantly different.

```{r rank-vs-taua_results_comparison}

d.tdic.taua <- stats.subjs.taua %>%
  filter(param %in% c("incongruency", "target", "distractor", "congruency")) %>%
  full_join(d.tdic.rank %>% select(subj, roi.hemi, param, beta))

rank.vs.taua.diff <- d.tdic.taua %>%  
  group_by(roi.hemi, param) %>%
  summarize(
    v    = wilcox.test(beta, taua, paired = TRUE)$statistic,
    p    = wilcox.test(beta, taua, paired = TRUE)$p.value,
    diff = tanh(mean(atanh(beta) - atanh(taua))),  ## must be last in this summarize()
  ) %>%
  filter(p < 0.05) %>%
  as.data.frame

## target

rank.vs.taua.diff %>% 
  filter(
    param == "target", roi.hemi %in% c(
      ## union of sets:
      rank.vs.taua.intersect$target, 
      rank.vs.taua.notintaua$target, 
      rank.vs.taua.notinrank$target
      )
    ) %>%
  arrange(diff)

## distractor

rank.vs.taua.diff %>% 
  filter(
    param == "distractor", roi.hemi %in% c(
      ## union of sets:
      rank.vs.taua.intersect$distractor, 
      rank.vs.taua.notintaua$distractor, 
      rank.vs.taua.notinrank$distractor
      )
    ) %>%
  arrange(diff)

## incongruency

rank.vs.taua.diff %>% 
  filter(
    param == "incongruency", roi.hemi %in% c(
      ## union of sets:
      rank.vs.taua.intersect$incongruency, 
      rank.vs.taua.notintaua$incongruency, 
      rank.vs.taua.notinrank$incongruency
      )
    ) %>%
  arrange(diff)
```

All differences are positive (i.e., greater betas than $\tau_A$).

```{r rank-vs-taua_results_plot}

## plot

plot.new()

for (ii in seq_along(params)) {
  
  # plot.new()
  par(mfrow = c(1, 2))
  
  d.tdic.taua %>%
    filter(param == params[ii]) %>%
    group_by(subj) %>%
    summarize_if(is.numeric, function(x) tanh(mean(atanh(x)))) %>%
    select(beta, taua) %>%
    plot
  abline(0, 1)
  title("by subject")
  
  d.tdic.taua %>%
    filter(param == params[ii]) %>%
    group_by(roi.hemi) %>%
    summarize_if(is.numeric, function(x) tanh(mean(atanh(x)))) %>%
    select(beta, taua) %>%
    plot
  abline(0, 1)
  title("by ROI")
  
  mtext(
    paste0("association between ", params[ii], " estimates from tau-a versus rank regression models"),
    side = 3, line = -1, outer = TRUE
    )
  
  d.tdic.taua %>%
    filter(param == params[ii]) %>%
    group_by(subj) %>%
    summarize_if(is.numeric, function(x) tanh(mean(atanh(x)))) %>%
    select(taua, beta) %>%
    cor %>%
    print

  d.tdic.taua %>%
    filter(param == params[ii]) %>%
    group_by(roi.hemi) %>%
    summarize_if(is.numeric, function(x) tanh(mean(atanh(x)))) %>%
    select(taua, beta) %>%
    cor %>%
    print
  
}


```


#### __preference analysis__: pairwise comparisons


```{r preference_results_taua-vs-tdic_target}

rank.vs.taua.intersect

## target vs distractor

rois.taua.targt.vs.distr <- stats.pairs.taua %>% 
  filter(
    roi.hemi %in% rank.vs.taua.intersect$target,
    p.targt.distr < 0.05,
    b.targt.distr > 0
    ) %>%
  .$roi.hemi
                            
rois.tdic.targt.vs.distr <- stats.pairs.tdic %>% 
  filter(
      roi.hemi %in% rank.vs.taua.intersect$target,
      p.targt.distr < 0.05,
      b.targt.distr > 0
    ) %>%
  .$roi.hemi

setdiff(rois.taua.targt.vs.distr, rois.tdic.targt.vs.distr)
setdiff(rois.tdic.targt.vs.distr, rois.taua.targt.vs.distr)

## target vs incongruency

rois.taua.targt.vs.incon <- stats.pairs.taua %>% 
  filter(
    roi.hemi %in% rank.vs.taua.intersect$target,
    p.targt.incon < 0.05,
    b.targt.incon > 0,
    ) %>%
  .$roi.hemi
                            
rois.tdic.targt.vs.incon <- stats.pairs.tdic %>% 
  filter(
      roi.hemi %in% rank.vs.taua.intersect$target,
      p.targt.incon < 0.05,
      b.targt.incon > 0,
    ) %>%
  .$roi.hemi

setdiff(rois.taua.targt.vs.incon, rois.tdic.targt.vs.incon)
setdiff(rois.tdic.targt.vs.incon, rois.taua.targt.vs.incon)

```

## conclusions

$\tau_A$ models have expectedly worse (lower) fits than the rank regression models.
This is expected because the $\tau_A$ are *bivariate* correlations, and the variables are negatively correlated.
Thus, this comparison, as implemented here, is unfair.

A more appropriate comparison shold be performed by first orthogonalizing the variables, then computing $\tau_A$.
TODO!